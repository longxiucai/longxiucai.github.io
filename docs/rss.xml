<?xml version='1.0' encoding='UTF-8'?>
<rss xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0"><channel><title>龙宇翔的小本本</title><link>https://longxiucai.github.io</link><description> </description><copyright>龙宇翔的小本本</copyright><docs>http://www.rssboard.org/rss-specification</docs><generator>python-feedgen</generator><image><url>https://github.githubassets.com/favicons/favicon.svg</url><title>avatar</title><link>https://longxiucai.github.io</link></image><lastBuildDate>Tue, 02 Jul 2024 05:40:51 +0000</lastBuildDate><managingEditor>龙宇翔的小本本</managingEditor><ttl>60</ttl><webMaster>龙宇翔的小本本</webMaster><item><title>临时修改initrd.img</title><link>https://longxiucai.github.io/post/lin-shi-xiu-gai-initrd.img.html</link><description>## 解压&#13;
mkdir tmpdir&#13;
cd tmpdir&#13;
xzcat -d ../initrd.img | cpio -idum   #解压img输出到当前所在目录&#13;
&#13;
## 修改&#13;
....&#13;
&#13;
## 重新打包&#13;
find . | cpio -oH newc | xz --check=crc32 -9 &gt; ../initrd.img&#13;
&#13;
cpio -H参数说明：&#13;
* bin 过时的二进制格式。</description><guid isPermaLink="true">https://longxiucai.github.io/post/lin-shi-xiu-gai-initrd.img.html</guid><pubDate>Tue, 02 Jul 2024 05:40:28 +0000</pubDate></item><item><title>正则表达式</title><link>https://longxiucai.github.io/post/zheng-ze-biao-da-shi.html</link><description>## 元字符说明&#13;
&#13;
    元字符:  |&#13;
    匹配规则:匹配|两边任意一个正则表达式&#13;
&#13;
    元字符:  .&#13;
    匹配规则:匹配除换行外的任意字符&#13;
&#13;
    元字符:  ^&#13;
    匹配规则:匹配目标字符串的开头位置&#13;
&#13;
    元字符:  $&#13;
    匹配规则:匹配字符串的结束位置&#13;
&#13;
    元字符:  *&#13;
    匹配规则:匹配前面的字符出现0次或多次&#13;
&#13;
    元字符:  +&#13;
    匹配规则:匹配前面的字符出现一次或多次&#13;
&#13;
	元字符:  ?&#13;
	匹配规则:匹配前面的字符出现0次或1次&#13;
&#13;
    元字符:  {n}&#13;
    匹配规则:匹配指定的重复次数&#13;
   &#13;
	 元字符: {m,n}   &#13;
    匹配规则:匹配前面的正则表达式 m--n次        &#13;
&#13;
&#13;
## 匹配字符集合&#13;
&#13;
* 元字符:`[字符集]`&#13;
&#13;
    匹配规则:匹配任意一个字符集下的字符&#13;
```&#13;
    [abc123] a b c 1 2 3 12 &#13;
	[a-z] [0-9] [_123a-z]&#13;
    eg:&#13;
    &gt;&gt;&gt; re.findall('^[a-z][a-z]','boy')&#13;
    ['bo']&#13;
```&#13;
* 元字符:`[^...]`&#13;
&#13;
    匹配规则:字符集取非,除了列出的字符之外任意一个字符&#13;
```&#13;
    [^abc]--&gt;除abc之外任意字符&#13;
    eg:&#13;
    &gt;&gt;&gt; re.findall('[^abcds]','boyadshfhjasjhbhjasf')&#13;
    ['o', 'y', 'h', 'f', 'h', 'j', 'j', 'h', 'h', 'j', 'f']&#13;
```&#13;
&#13;
* 元字符: `\d`  `\D`&#13;
&#13;
    匹配规则: &#13;
&#13;
    `\d` 匹配任意数字字符      [0-9]&#13;
    &#13;
    `\D` 匹配任意非数字字符    [^0-9]&#13;
```&#13;
    eg:&#13;
    &gt;&gt;&gt; re.findall('\D','AID1807')&#13;
    ['A', 'I', 'D']&#13;
&#13;
	\1,\2	反向引用	匹配之前第一、第二括号内表达式匹配的内容&#13;
&#13;
	举个例子，想找到连续两个重复单词，我们就必须要知道前面单词是什么，这时候就可以使用反向引用了，可以简单写为(\w+)\s+\1&#13;
```&#13;
	&#13;
* 元字符:`\w`  `\W`&#13;
    匹配规则:&#13;
&#13;
    `\w` 普通字符  &#13;
    &#13;
    `\W` 非普通字符&#13;
```&#13;
    eg:&#13;
    &gt;&gt;&gt; re.findall('\w','我在北京')&#13;
    ['我', '在', '北', '京']&#13;
            &#13;
    &gt;&gt;&gt; re.findall('\W','!@#$我在北京')&#13;
    ['!', '@', '#', '$']&#13;
```&#13;
&#13;
* 元字符: `\s` `\S`&#13;
    匹配规则:&#13;
&#13;
    `\s` 匹配任意空字符`[\r\t\n\v\f]`&#13;
&#13;
    `\S` 匹配任意非空字符&#13;
```&#13;
    eg:&#13;
    &gt;&gt;&gt; re.findall('\w+\s+\w+','hello     beijin')&#13;
    ['hello     beijin']&#13;
    &gt;&gt;&gt; re.findall('\w+\S+\w+','hello     beijin')&#13;
    ['hello', 'beijin']&#13;
```&#13;
* 元字符: `\A` `\Z`&#13;
   &#13;
    匹配规则:&#13;
    &#13;
    `\A` 匹配字符串开头位置  `^`&#13;
&#13;
    `\Z` 匹配字符串结尾位置  `$`&#13;
```&#13;
    &gt;&gt;&gt; re.findall('\Ahello','hellobeijin')&#13;
    ['hello']&#13;
    &gt;&gt;&gt; re.findall('beijin\Z','hellobeijin')&#13;
    ['beijin']&#13;
```&#13;
绝对匹配:正则表达式完全匹配目标字符串内容&#13;
&#13;
在正则表达式的开头或者结尾加上`^`或者`$`(或者`\A` `\Z`).这样正则表达式必须匹配到整个目标字符串才会有结果&#13;
```&#13;
    eg:&#13;
    &gt;&gt;&gt; re.findall('\A\d+$','1234568789')&#13;
    ['1234568789']&#13;
&#13;
    匹配(非)单词边界&#13;
    \&lt;	单词分界符	匹配单词开始	java中使用\b&#13;
	\&gt;	单词分界符	匹配单词结束	java中使用\B&#13;
```&#13;
* 元字符: `\b` `\B`&#13;
    &#13;
    匹配规则:&#13;
    &#13;
    `\b` 匹配单词边界位置&#13;
&#13;
    `\B` 匹配非单词边界位置&#13;
            普通字符和非普通字符认为是单词边界&#13;
```&#13;
    eg:&#13;
    &gt;&gt;&gt; re.findall(r'he\b','he ##is a good gril')&#13;
    ['he']&#13;
```&#13;
 &#13;
## 元字符总结&#13;
&#13;
匹配单个字符: &#13;
```&#13;
a  .  \d   \D  \s  \S  \w   \W  [...]  [^...]&#13;
```&#13;
匹配重复: &#13;
```&#13;
*  +  ?  {n}  {m,n}&#13;
```&#13;
匹配位置:&#13;
```&#13;
^  $  \A  \Z  \b  \B&#13;
```&#13;
其他: &#13;
```&#13;
|  ()  \&#13;
```&#13;
## 正则表达式转义&#13;
&#13;
正则中的特殊字符&#13;
```&#13;
. * + ? ^ $ [] {} () | \&#13;
```&#13;
正则表达式如果匹配特殊字符需要加`\`表达转义&#13;
```&#13;
    eg:             正则  目标字符串&#13;
    &gt;&gt;&gt; re.findall('\$\d+','$10')&#13;
    ['$10']&#13;
&#13;
             pattern     string&#13;
    python  '\\$\\d+'     '$10'&#13;
    python   r'\$\d+'     '$10'&#13;
&#13;
    raw子串: 原始字符串对内容不解释转义,就表达内容原本的意义&#13;
```&#13;
## 贪婪和非贪婪&#13;
&#13;
贪婪模式:正则表达式的重复匹配总是尽可能多的向后匹配更多内容`* + ? {m,n}`&#13;
&#13;
非贪婪模式(懒惰模式):尽可能少的匹配内容&#13;
```&#13;
    贪婪---&gt;非贪婪 *?  +?  ??   {m,n}?&#13;
    &gt;&gt;&gt; re.findall(r'ab','abbbbbbbbbbb')&#13;
    ['ab']&#13;
    &#13;
    &gt;&gt;&gt; re.findall(r'ab+','abbbbbbbbbbb')&#13;
    ['abbbbbbbbbbb']&#13;
    &#13;
    &gt;&gt;&gt; re.findall(r'ab{3,5}?','abbbbbbbbbbb')&#13;
    ['abbb']&#13;
```&#13;
## 正则表达式的子组&#13;
可以使用()为正则表达式建立子组,子组可以看做是正则表达式内部操作的一个整体&#13;
&#13;
子组是在正则表达式整体匹配到内容的前提下才会发挥的作用,他不影响正则表达式整体去匹配目标内容这一原则&#13;
&#13;
子组作用&#13;
&#13;
1.作为内部整体可以改变某些原字符的行为&#13;
    eg:&#13;
    &gt;&gt;&gt; re.search(r'(ab)+\d+','abababab123456').group()&#13;
    'abababab123456'&#13;
&#13;
2.子组在某些操作中可以单独提取出匹配内容&#13;
    &gt;&gt;&gt; re.search(r'(https|http|ftp)://\S+','https://baidu.com').group()&#13;
    'https://baidu.com'&#13;
&#13;
&#13;
子组使用注意事项:&#13;
* 一个正则表达式中可以有多个子组&#13;
* 子组一般由外到内,左到右称之为第一,第二,第三...子组&#13;
* 子组不能重叠,嵌套也不宜很复杂&#13;
&#13;
&#13;
## 捕获组和非捕获组&#13;
&#13;
格式:&#13;
```&#13;
(?P&lt;name&gt;pattern)&#13;
&#13;
&gt;&gt;&gt; re.search(r'(?P&lt;dog&gt;ab)cdef','abcdefghijklmn').group('dog')&#13;
'ab'&#13;
```&#13;
作用:可以通过组名更方便获取某组内容。</description><guid isPermaLink="true">https://longxiucai.github.io/post/zheng-ze-biao-da-shi.html</guid><pubDate>Tue, 02 Jul 2024 05:36:57 +0000</pubDate></item><item><title>修改pod网段与calico配置</title><link>https://longxiucai.github.io/post/xiu-gai-pod-wang-duan-yu-calico-pei-zhi.html</link><description>1. vim /etc/kubernetes/manifests/kube-controller-manager.yaml 【3个master一个一个的执行，最好是kube-controller-manager-节点名字的pod Running之后再修改下一个节点】&#13;
		19行：--cluster-cidr=10.128.0.0/18&#13;
&#13;
2. kubectl edit cm kubeadm-config -n kube-system&#13;
		podSubnet: 10.128.0.0/18&#13;
&#13;
3. kubectl edit cm kube-proxy -n kube-system&#13;
		clusterCIDR: 10.128.0.0/18&#13;
&#13;
4. kubectl edit ippool default-ipv4-ippool&#13;
		cidr: 10.128.0.0/18&#13;
&#13;
5. kubectl edit cm calico-config -n kube-system ：&#13;
          'ipam': {&#13;
              'type': 'calico-ipam',					              #逗号&#13;
              'ipv4_pools': ['default-ipv4-ippool']   #添加此行，前面必须是空格不能是tab&#13;
          },&#13;
&#13;
6. kubectl rollout restart -n kube-system daemonset.apps/calico-node&#13;
等待calico的pod全部running，全部节点查看配置文件是否有'ipv4_pools': ['default-ipv4-ippool']：&#13;
cat /etc/cni/net.d/00-multus.conf&#13;
cat /etc/cni/net.d/10-calico.conflist&#13;
&#13;
7. kubectl  edit ippool kubevirt-vm-ippool&#13;
  cidr: 10.128.128.0/18&#13;
&#13;
8. kubectl delete ippool other-ippool&#13;
&#13;
9. kubectl cluster-info dump | grep cluster-cidr&#13;
&#13;
&#13;
默认使用default pool，开启noipam功能&#13;
calico-config configMap:&#13;
cni.projectcalico.org/ipAddrsNoIpam&#13;
```&#13;
apiVersion: v1&#13;
data:&#13;
  calico_backend: bird&#13;
  cni_network_config: |-&#13;
    {&#13;
      'name': 'k8s-pod-network',&#13;
      'cniVersion': '0.3.1',&#13;
      'plugins': [&#13;
        {&#13;
          'type': 'calico',&#13;
          'log_level': 'info',&#13;
          'log_file_path': '/var/log/calico/cni/cni.log',&#13;
          'datastore_type': 'kubernetes',&#13;
          'nodename': '__KUBERNETES_NODE_NAME__',&#13;
          'mtu': __CNI_MTU__,&#13;
          'ipam': {&#13;
              'type': 'calico-ipam',&#13;
              'ipv4_pools': ['default-ipv4-ippool']&#13;
          },&#13;
          'policy': {&#13;
              'type': 'k8s'&#13;
          },&#13;
          'kubernetes': {&#13;
              'kubeconfig': '__KUBECONFIG_FILEPATH__'&#13;
          },&#13;
         'feature_control': {&#13;
             'ip_addrs_no_ipam': true&#13;
         }&#13;
        },&#13;
        {&#13;
          'type': 'portmap',&#13;
          'snat': true,&#13;
          'capabilities': {'portMappings': true}&#13;
        },&#13;
        {&#13;
          'type': 'bandwidth',&#13;
          'capabilities': {'bandwidth': true}&#13;
        }&#13;
      ]&#13;
    }&#13;
  typha_service_name: none&#13;
  veth_mtu: '0'&#13;
kind: ConfigMap&#13;
metadata:&#13;
  name: calico-config&#13;
  namespace: kube-system&#13;
```&#13;
&#13;
。</description><guid isPermaLink="true">https://longxiucai.github.io/post/xiu-gai-pod-wang-duan-yu-calico-pei-zhi.html</guid><pubDate>Tue, 02 Jul 2024 03:23:13 +0000</pubDate></item><item><title>go解析证书文件</title><link>https://longxiucai.github.io/post/go-jie-xi-zheng-shu-wen-jian.html</link><description>```&#13;
package cert&#13;
&#13;
import (&#13;
	'crypto/x509'&#13;
	'encoding/pem'&#13;
	'os'&#13;
	'path/filepath'&#13;
	'strings'&#13;
	'time'&#13;
&#13;
	log 'github.com/sirupsen/logrus'&#13;
)&#13;
&#13;
func parseCertificate(file string) {&#13;
	// 读取文件内容&#13;
	fileData, err := os.ReadFile(file)&#13;
	if err != nil {&#13;
		log.Errorf('Error reading file %s: %s\n', file, err)&#13;
		return&#13;
	}&#13;
&#13;
	// 解析 PEM 块&#13;
	block, _ := pem.Decode(fileData)&#13;
	if block == nil {&#13;
		log.Errorf('No PEM block found in file %s\n', file)&#13;
		return&#13;
	}&#13;
&#13;
	// 判断文件类型&#13;
	fileType := strings.ToLower(filepath.Ext(file))&#13;
	switch fileType {&#13;
	case '.crt', '.pem':&#13;
		// 解析证书&#13;
		cert, err := x509.ParseCertificate(block.Bytes)&#13;
		if err != nil {&#13;
			log.Errorf('Error parsing certificate from file %s: %s\n', file, err)&#13;
			return&#13;
		}&#13;
&#13;
		// 输出证书有效期等信息&#13;
		log.Infof('Certificate in file %s:', file)&#13;
		log.Infof('  Subject: %s', cert.Subject.CommonName)&#13;
		log.Infof('  Valid from: %s', cert.NotBefore)&#13;
		log.Infof('  Valid until: %s', cert.NotAfter)&#13;
&#13;
		// 计算证书有效期结束时间与当前时间之间的天数差&#13;
		now := time.Now()&#13;
		expiresInDays := int((time.Duration(cert.NotAfter.Sub(now).Hours()) / 24))&#13;
		log.Infof('证书%s 将于 %d 天后过期', cert.Subject.CommonName, expiresInDays)&#13;
		log.Infof('---------------------------')&#13;
	default:&#13;
		log.Infof('Unsupported file type: %s %s', fileType, file)&#13;
	}&#13;
}&#13;
```。</description><guid isPermaLink="true">https://longxiucai.github.io/post/go-jie-xi-zheng-shu-wen-jian.html</guid><pubDate>Tue, 02 Jul 2024 02:33:15 +0000</pubDate></item><item><title>go连接数据库</title><link>https://longxiucai.github.io/post/go-lian-jie-shu-ju-ku.html</link><description>```&#13;
package dbtest&#13;
&#13;
import (&#13;
	'database/sql'&#13;
	'fmt'&#13;
	'log'&#13;
&#13;
	_ 'github.com/go-sql-driver/mysql'&#13;
)&#13;
&#13;
func maindb() {&#13;
	// 连接 MySQL 数据库&#13;
	db, err := sql.Open('mysql', 'dbinit:123456@tcp(10.42.186.232:3306)/dbinit_test')&#13;
	if err != nil {&#13;
		log.Fatal(err)&#13;
	}&#13;
	defer db.Close()&#13;
&#13;
	// 测试连接&#13;
	err = db.Ping()&#13;
	if err != nil {&#13;
		log.Fatal('Error connecting to the database:', err)&#13;
	}&#13;
&#13;
	fmt.Println('Connected to MySQL database successfully!')&#13;
&#13;
	// 查询示例&#13;
	rows, err := db.Query('SELECT * FROM users')&#13;
	if err != nil {&#13;
		log.Fatal('Error executing query:', err)&#13;
	}&#13;
	defer rows.Close()&#13;
&#13;
	// 遍历查询结果&#13;
	for rows.Next() {&#13;
		var id int&#13;
		var name string&#13;
		err := rows.Scan(&amp;id, &amp;name)&#13;
		if err != nil {&#13;
			log.Fatal('Error scanning row:', err)&#13;
		}&#13;
		fmt.Printf('ID: %d, Name: %s\n', id, name)&#13;
	}&#13;
}&#13;
```。</description><guid isPermaLink="true">https://longxiucai.github.io/post/go-lian-jie-shu-ju-ku.html</guid><pubDate>Tue, 02 Jul 2024 02:04:36 +0000</pubDate></item></channel></rss>
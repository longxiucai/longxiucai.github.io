<?xml version='1.0' encoding='UTF-8'?>
<rss xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0"><channel><title>龙宇翔的小本本</title><link>https://longxiucai.github.io</link><description> </description><copyright>龙宇翔的小本本</copyright><docs>http://www.rssboard.org/rss-specification</docs><generator>python-feedgen</generator><image><url>https://github.githubassets.com/favicons/favicon.svg</url><title>avatar</title><link>https://longxiucai.github.io</link></image><lastBuildDate>Tue, 02 Jul 2024 06:18:30 +0000</lastBuildDate><managingEditor>龙宇翔的小本本</managingEditor><ttl>60</ttl><webMaster>龙宇翔的小本本</webMaster><item><title>linux安装启动过程</title><link>https://longxiucai.github.io/post/linux-an-zhuang-qi-dong-guo-cheng.html</link><description>1. isolinux.bin &amp; isolinux.cfg&#13;
&#13;
isolinux.bin是光盘引导程序，在mkisofs的选项中需要明确给出文件路径，这个文件属于SYSLINUX项目，对应fedora13中的syslinux包，文档可参考：/usr/share/doc/syslinux-4.02/isolinux.txt或者项目Wiki；可引导光盘相关信息请参考El Torito规范；&#13;
isolinux.cfg是isolinux.bin的配置文件，当光盘启动后（即运行isolinux.bin），会自动去找isolinux.cfg文件，然后根据配置信息进行后续工作；查找isolinux.cfg的顺序为:&#13;
boot/syslinux/isolinux.cfg&#13;
syslinux/isolinux.cfg&#13;
isolinux.cfg&#13;
&#13;
2. vesamenu.c32&#13;
&#13;
vesamenu.c32就是我们看到的光盘启动后的安装图形界面，也属于SYSLINUX项目，还有一个menu.c32版本，是纯文本的菜单；&#13;
&#13;
3. memtest&#13;
&#13;
如果通过光盘启动菜单选择了memtest选项，则开始进行内存检测；这是一个独立的程序，属于memtest86+项目，对应的fedora13的包是memtest86+-4.00-3.fc13.i686.rpm；通过效验md5值可以发现这个文件就是从包中提取出来的，发行版定制工具会从yum源将这个包安装到chroot中，然后将 /boot/memtest86+* 复制到ISO根目录；&#13;
&#13;
4. splash.jgp&#13;
&#13;
是光盘启动界面的背景图，应该来自文件 /usr/lib/anaconda-runtime/syslinux-vesa-splash.jpg，属于fedora-logos包；制作方法见Fedora官方Wiki：[How_to_create_a_custom_syslinux_splash](https://fedoraproject.org/wiki/How_to_create_a_custom_syslinux_splash)&#13;
&#13;
5. vmlinuz &amp; initrd.img&#13;
&#13;
vmlinuz是内核映像，initrd.img是ramfs (先cpio，再gzip压缩)，都是编译内核生成的；isolinux.bin根据安装选项找到对应的配置，装载内核和ramfs；&#13;
&#13;
6. install.img&#13;
&#13;
install.img是一个squashfs根文件系统，当内核启动后就装载install.img并切换根文件系统，执行里面的anaconda程序，anaconda是fedora的安装程序；&#13;
```&#13;
    $ sudo mount install.img /mnt -oloop   # mount&#13;
    $ sudo mksquashfs /dir                 # build&#13;
```&#13;
7. discinfo&#13;
&#13;
安装过程中，anaconda会去读取.discinfo文件，获取光盘信息（以前CD安装系统需要多张光盘），内容如下：&#13;
1273712438.740122     # timestamp （ python time.time() ）&#13;
Fedora 13             # releasestr&#13;
i386                  # arch&#13;
ALL                   # discNum （ALL表示只有一张安装盘）&#13;
注：参考文件/usr/lib/anaconda-runtime/makestamp.py &#13;
&#13;
8.Packages &amp; repodata&#13;
&#13;
packages就是存放包的目录，对这个目录执行createrepo命令就会生成一个repodata的目录，这个repodata就是yum源，里面的文件基本都是xml格式，记录了Packages中所有包的基本信息，如包名、包信息、包版本、包中的文件清单等等；&#13;
&#13;
。</description><guid isPermaLink="true">https://longxiucai.github.io/post/linux-an-zhuang-qi-dong-guo-cheng.html</guid><pubDate>Tue, 02 Jul 2024 06:18:07 +0000</pubDate></item><item><title>curl k8s api</title><link>https://longxiucai.github.io/post/curl%20k8s%20api.html</link><description>1. apply下面的资源文件&#13;
```&#13;
apiVersion: rbac.authorization.k8s.io/v1&#13;
kind: ClusterRoleBinding&#13;
metadata:&#13;
  name: test&#13;
roleRef:&#13;
  apiGroup: rbac.authorization.k8s.io&#13;
  kind: ClusterRole&#13;
  name: cluster-admin&#13;
subjects:&#13;
  - kind: ServiceAccount&#13;
    name: test&#13;
    namespace: kube-system&#13;
---&#13;
apiVersion: v1&#13;
kind: ServiceAccount&#13;
metadata:&#13;
  name: test&#13;
  namespace: kube-system&#13;
```&#13;
2. 执行下面命令(替换`KUBE_API`为实际)&#13;
```&#13;
JWT_TOKEN_KUBESYSTEM_DEFAULT=`kubectl get -n kube-system secret $(kubectl get serviceaccount -n kube-system test -o jsonpath='{.secrets[0].name}') -o jsonpath='{.data.token}' | base64 --decode`&#13;
KUBE_API=https://172.20.187.11:6443&#13;
```&#13;
3. 请求&#13;
```&#13;
curl  $KUBE_API/apis/apps/v1/deployments  --header 'Authorization: Bearer $JWT_TOKEN_KUBESYSTEM_DEFAULT' -k&#13;
```。</description><guid isPermaLink="true">https://longxiucai.github.io/post/curl%20k8s%20api.html</guid><pubDate>Tue, 02 Jul 2024 06:13:16 +0000</pubDate></item><item><title>linux家目录下的中文目录修改为英文</title><link>https://longxiucai.github.io/post/linux-jia-mu-lu-xia-de-zhong-wen-mu-lu-xiu-gai-wei-ying-wen.html</link><description>1. 将这些目录修改为英文名，如：  mv 桌面 Desktop &#13;
&#13;
2. 修改配置文件`~/.config/user-dirs.dirs`，将对应的路径改为英文名（要和1中修改的英文名对应）&#13;
&#13;
配置文件修改后的内容如下：&#13;
```&#13;
XDG_DESKTOP_DIR='$HOME/Desktop'&#13;
XDG_DOWNLOAD_DIR='$HOME/Download'&#13;
XDG_TEMPLATES_DIR='$HOME/Template'&#13;
XDG_PUBLICSHARE_DIR='$HOME/Public'&#13;
XDG_DOCUMENTS_DIR='$HOME/Document'&#13;
XDG_MUSIC_DIR='$HOME/Music'&#13;
XDG_PICTURES_DIR='$HOME/Picture'&#13;
XDG_VIDEOS_DIR='$HOME/Video'&#13;
```。</description><guid isPermaLink="true">https://longxiucai.github.io/post/linux-jia-mu-lu-xia-de-zhong-wen-mu-lu-xiu-gai-wei-ying-wen.html</guid><pubDate>Tue, 02 Jul 2024 06:09:53 +0000</pubDate></item><item><title>k8s dashbord的token创建，用于登录</title><link>https://longxiucai.github.io/post/k8s%20dashbord-de-token-chuang-jian-%EF%BC%8C-yong-yu-deng-lu.html</link><description>```&#13;
kubectl create serviceaccount cluster-admin-dashboard-sa&#13;
kubectl create clusterrolebinding cluster-admin-dashboard-sa --clusterrole=cluster-admin --serviceaccount=default:cluster-admin-dashboard-sa&#13;
kubectl describe secrets $(kubectl get secret | grep cluster-admin-dashboard-sa |cut -d ' ' -f1)|grep 'token:'&#13;
```。</description><guid isPermaLink="true">https://longxiucai.github.io/post/k8s%20dashbord-de-token-chuang-jian-%EF%BC%8C-yong-yu-deng-lu.html</guid><pubDate>Tue, 02 Jul 2024 06:06:03 +0000</pubDate></item><item><title>彩色echo</title><link>https://longxiucai.github.io/post/cai-se-echo.html</link><description>```&#13;
################# color code ####################&#13;
RED='31;1m'      # Error message&#13;
GREEN='32;1m'    # Success message&#13;
YELLOW='33;1m'   # Warning message&#13;
BLUE='36;1m'     # Info message&#13;
LIGHT_BLUE='36m' # Debug message&#13;
################# color echo ####################&#13;
colorEcho() { echo -e '\033[${1}${@:2}\033[0m'; }&#13;
error() { colorEcho $RED $1; }&#13;
success() { colorEcho $GREEN $1; }&#13;
warn() { colorEcho $YELLOW $1; }&#13;
info() { colorEcho $BLUE $1; }&#13;
################ end of color echo ##############&#13;
```。</description><guid isPermaLink="true">https://longxiucai.github.io/post/cai-se-echo.html</guid><pubDate>Tue, 02 Jul 2024 06:04:42 +0000</pubDate></item><item><title>c程序占用文件描述符</title><link>https://longxiucai.github.io/post/c-cheng-xu-zhan-yong-wen-jian-miao-shu-fu.html</link><description>## c程序打开多个文件&#13;
```&#13;
#include &lt;stdio.h&gt;&#13;
#include &lt;stdlib.h&gt;&#13;
#include &lt;fcntl.h&gt;&#13;
#include &lt;unistd.h&gt;&#13;
#include &lt;signal.h&gt;&#13;
&#13;
int *fds = NULL;&#13;
int number_of_files = 0;&#13;
int last_files = 0;&#13;
void cleanup() {&#13;
    if (fds != NULL) {&#13;
        for (int i = 0; i &lt; last_files + 1; i++) {&#13;
            if (fds[i] != -1) {&#13;
                close(fds[i]);&#13;
                printf('Closed file descriptor %d\n', fds[i]);&#13;
            }&#13;
&#13;
            char filename[256];&#13;
            snprintf(filename, sizeof(filename), '/tmp/testfile_%d.txt', i);&#13;
            if (unlink(filename) == 0) {&#13;
                printf('Deleted file %s\n', filename);&#13;
            } else {&#13;
                perror('unlink');&#13;
            }&#13;
        }&#13;
        free(fds);&#13;
        fds = NULL;&#13;
        printf('Freed allocated memory\n');&#13;
    }&#13;
}&#13;
&#13;
void signal_handler(int signal) {&#13;
    if (signal == SIGINT) {&#13;
        printf('\nCaught SIGINT signal, performing cleanup...\n');&#13;
        cleanup();&#13;
        exit(EXIT_FAILURE);&#13;
    }&#13;
}&#13;
&#13;
void open_many_files(int num_files) {&#13;
    number_of_files = num_files;&#13;
    fds = malloc(number_of_files * sizeof(int));&#13;
    if (fds == NULL) {&#13;
        perror('malloc');&#13;
        exit(EXIT_FAILURE);&#13;
    }&#13;
&#13;
    for (int i = 0; i &lt; number_of_files; i++) {&#13;
        char filename[256];&#13;
        snprintf(filename, sizeof(filename), '/tmp/testfile_%d.txt', i);&#13;
        fds[i] = open(filename, O_RDWR | O_CREAT, 0644);&#13;
        if (fds[i] == -1) {&#13;
            perror('open');&#13;
            break;&#13;
        }&#13;
        printf('Opened file descriptor %d for %s\n', fds[i], filename);&#13;
        last_files = i;&#13;
    }&#13;
}&#13;
&#13;
int main(int argc, char *argv[]) {&#13;
    if (argc != 3) {&#13;
        fprintf(stderr, 'Usage: %s &lt;number_of_files_to_open&gt; &lt;wait_time_in_seconds&gt;\n', argv[0]);&#13;
        exit(EXIT_FAILURE);&#13;
    }&#13;
&#13;
    // Register the signal handler for SIGINT&#13;
    signal(SIGINT, signal_handler);&#13;
&#13;
    int num_files_to_open = atoi(argv[1]);&#13;
    int wait_time = atoi(argv[2]);&#13;
&#13;
    open_many_files(num_files_to_open);&#13;
&#13;
    // Wait for the specified time before closing file descriptors&#13;
    printf('Waiting for %d seconds before closing file descriptors...\n', wait_time);&#13;
    sleep(wait_time);&#13;
&#13;
    cleanup();&#13;
&#13;
    return 0;&#13;
}&#13;
```&#13;
## 在pod中复现`too many open files in system`的情况&#13;
*  修改limit.conf中nofile，现在文件打开数量，在pod中不会报错，直接在宿主机中运行程序会报错&#13;
*  修改内核参数fs.file-max，降低值内核参数的值，pod中会报错。</description><guid isPermaLink="true">https://longxiucai.github.io/post/c-cheng-xu-zhan-yong-wen-jian-miao-shu-fu.html</guid><pubDate>Tue, 02 Jul 2024 06:03:36 +0000</pubDate></item><item><title>cgroup&amp;多线程测试</title><link>https://longxiucai.github.io/post/cgroup%26-duo-xian-cheng-ce-shi.html</link><description>## C代码：thread.c&#13;
```&#13;
#include&lt;stdio.h&gt;&#13;
#include&lt;stdlib.h&gt;&#13;
#include&lt;pthread.h&gt;&#13;
#include &lt;unistd.h&gt; &#13;
/* 声明结构体 */&#13;
struct member&#13;
{&#13;
    int num;&#13;
    char *name;&#13;
};     &#13;
&#13;
/* 定义线程pthread */&#13;
static void * pthread(void *arg)       &#13;
{&#13;
    struct member *temp;&#13;
    &#13;
    /* 线程pthread开始运行 */&#13;
    printf('pthread start!\n');&#13;
    while(1){&#13;
    ;&#13;
    }&#13;
    /* 令主线程继续执行 */&#13;
    sleep(2);&#13;
    &#13;
    /* 打印传入参数 */&#13;
    temp = (struct member *)arg;      &#13;
    printf('member-&gt;num:%d\n',temp-&gt;num);&#13;
    printf('member-&gt;name:%s\n',temp-&gt;name);&#13;
    &#13;
    return NULL;&#13;
}&#13;
&#13;
/* main函数 */&#13;
int main(int agrc,char* argv[])&#13;
{&#13;
    pthread_t tidp,tidp1;&#13;
    struct member *b;&#13;
&#13;
    /* 为结构体变量b赋值 */&#13;
    b = (struct member *)malloc(sizeof(struct member));           &#13;
    b-&gt;num=1;&#13;
    b-&gt;name='mlq';              &#13;
&#13;
    /* 创建线程pthread */&#13;
    if ((pthread_create(&amp;tidp, NULL, pthread, (void*)b)) == -1)&#13;
    {&#13;
        printf('create error!\n');&#13;
        return 1;&#13;
    }&#13;
    if ((pthread_create(&amp;tidp1, NULL, pthread, (void*)b)) == -1)&#13;
    {&#13;
        printf('create error!\n');&#13;
        return 1;&#13;
    }&#13;
&#13;
    /* 令线程pthread先运行 */&#13;
    sleep(1);&#13;
    &#13;
    /* 线程pthread睡眠2s，此时main可以先执行 */&#13;
    printf('main continue!\n');&#13;
    &#13;
    /* 等待线程pthread释放 */&#13;
    if (pthread_join(tidp, NULL))                  &#13;
    {&#13;
        printf('thread is not exit...\n');&#13;
        return -2;&#13;
    }&#13;
    &#13;
    return 0;&#13;
}&#13;
```&#13;
## 编译&#13;
```&#13;
gcc -o thread.out thread.c -lpthread&#13;
```&#13;
## 测试&#13;
1、`systemd-run --unit=threadtest --slice=test  /root/thread.out` 会启动一个临时服务,该服务就是运行/root/thread.out，名为threadtest.service&#13;
2、查看`top -H -p &lt;threadtest.service的pid&gt;`会显示该服务及其线程的信息&#13;
3、cgroup：/sys/fs/cgroup/cpu/test.slice/threadtest.service。</description><guid isPermaLink="true">https://longxiucai.github.io/post/cgroup%26-duo-xian-cheng-ce-shi.html</guid><pubDate>Tue, 02 Jul 2024 05:56:42 +0000</pubDate></item><item><title>bucketbench测试crio步骤</title><link>https://longxiucai.github.io/post/bucketbench-ce-shi-crio-bu-zou.html</link><description>1. 安装crio&#13;
&#13;
2. 修改crio配置文件的[crio.image]字段，添加一行pause_image      字段位于第444行&#13;
vim /etc/crio/crio.conf&#13;
[crio.image]&#13;
pause_image = 'harbor.kylincloudnative.com/registry.k8s.io/pause:3.6'&#13;
&#13;
3. 配置cgroup&#13;
mkdir -p /etc/crio/crio.conf.d&#13;
cat &gt;/etc/crio/crio.conf.d/02-cgroup-manager.conf&lt;&lt;-EOF&#13;
[crio.runtime]&#13;
conmon_cgroup = 'pod'&#13;
cgroup_manager = 'cgroupfs'&#13;
EOF&#13;
&#13;
&#13;
4. 重启并观察状态是否running&#13;
systemctl daemon-reload&#13;
systemctl restart crio&#13;
systemctl status crio&#13;
&#13;
5. 拉镜像，修改tag&#13;
```&#13;
podman pull harbor.kylincloudnative.com/library/alpine:latest&#13;
podman pull harbor.kylincloudnative.com/registry.k8s.io/pause:3.6&#13;
podman pull harbor.kylincloudnative.com/registry.k8s.io/pause:3.1&#13;
podman tag harbor.kylincloudnative.com/registry.k8s.io/pause:3.6 registry.aliyuncs.com/google_containes/pause:3.6&#13;
podman tag harbor.kylincloudnative.com/registry.k8s.io/pause:3.1 registry.aliyuncs.com/google_containers/pause:3.1&#13;
```&#13;
6. 修改测试工具配置文件&#13;
* 修改 contrib/container_config.json      位于第7行&#13;
image.image修改为harbor.kylincloudnative.com/library/alpine:latest&#13;
* 修改 examples/crio.yaml   位于第2行&#13;
image: harbor.kylincloudnative.com/library/alpine:latest&#13;
* 修改 examples/crio.yaml中的线程数相关配置：&#13;
   threads: xxxxxxxx&#13;
   iterations: xxxxxxxx.&#13;
&#13;
7. 测试 arm&#13;
./bucketbench-aarch64 --log-level=debug run -b   examples/crio.yaml --skip-limit&#13;
&#13;
&#13;
&gt; [!TIP]&#13;
&gt; 如报错`xxxxxx : name is reserved`，则需删除pod：&#13;
```&#13;
for i in $(crictl pods | awk -F ' ' '{print$1}' | xargs) ;do crictl stopp $i; done&#13;
for i in $(crictl pods | awk -F ' ' '{print$1}' | xargs) ;do crictl rmp $i; done&#13;
```&#13;
。</description><guid isPermaLink="true">https://longxiucai.github.io/post/bucketbench-ce-shi-crio-bu-zou.html</guid><pubDate>Tue, 02 Jul 2024 05:51:53 +0000</pubDate></item><item><title>bond配置</title><link>https://longxiucai.github.io/post/bond-pei-zhi.html</link><description>1. 配置ifcfg-xxx1接口 路径为 /etc/sysconfig/network-scripts/&#13;
TYPE=Ethernet&#13;
NAME=xxx1&#13;
BOOTPROTO=none&#13;
DEVICE=xxx1&#13;
ONBOOT=yes&#13;
MASTER=bond0&#13;
SLAVE=yes&#13;
2. 同1，配置ifcfg-xxx2接口&#13;
3. 新建ifcfg-bond0文件，内容如下&#13;
TYPE=Ethernet&#13;
NAME=bond0&#13;
BOOTPROTO=static&#13;
DEVICE=bond0&#13;
ONBOOT=yes&#13;
IPADDR=xxxx&#13;
NATMASK=XXXX&#13;
GATEWAY=172.20.43.253&#13;
DNS1=172.20.191.2&#13;
DNS2=114.114.114.114&#13;
BONDING_OPTS='mode=6 miimon=100'&#13;
4. 加载模块，让系统支持bonding    ？？？？？？&#13;
cat/etc/modprobe.conf？？？/etc/modprobe.d/bonding.conf？？？  //不存在的话，手动创建（也可以放在modprobe.d下面）&#13;
alias bond0 bonding&#13;
options bond0 miimon=100 mode=0&#13;
5. 加载bond module：modprobe bonding&#13;
6. systemctl restart network&#13;
7. 查看绑定结果&#13;
`cat  /proc/net/bonding/bond0`&#13;
&#13;
参考：&#13;
https://www.cnblogs.com/huangweimin/articles/6527058.html&#13;
https://blog.csdn.net/qq_34870631/article/details/80625217&#13;
。</description><guid isPermaLink="true">https://longxiucai.github.io/post/bond-pei-zhi.html</guid><pubDate>Tue, 02 Jul 2024 05:45:43 +0000</pubDate></item><item><title>网桥配置脚本</title><link>https://longxiucai.github.io/post/wang-qiao-pei-zhi-jiao-ben.html</link><description>#!/bin/bash&#13;
ifname=ens3&#13;
brname=bridge0&#13;
ip=172.20.43.11/24&#13;
gateway=172.20.43.253&#13;
dns='172.20.191.2,114.114.114.114'&#13;
nmcli connection add ifname $brname type bridge con-name $brname&#13;
nmcli connection delete ${ifname}&#13;
nmcli connection add type bridge-slave ifname ${ifname} master $brname&#13;
nmcli connection modify $brname ipv4.addresses $ip&#13;
nmcli connection modify $brname ipv4.gateway $gateway&#13;
nmcli connection modify $brname ipv4.dns $dns&#13;
nmcli connection modify $brname ipv4.method manual&#13;
nmcli connection up $brname。</description><guid isPermaLink="true">https://longxiucai.github.io/post/wang-qiao-pei-zhi-jiao-ben.html</guid><pubDate>Tue, 02 Jul 2024 05:43:51 +0000</pubDate></item><item><title>临时修改initrd.img</title><link>https://longxiucai.github.io/post/lin-shi-xiu-gai-initrd.img.html</link><description>## 解压&#13;
mkdir tmpdir&#13;
cd tmpdir&#13;
xzcat -d ../initrd.img | cpio -idum   #解压img输出到当前所在目录&#13;
&#13;
## 修改&#13;
....&#13;
&#13;
## 重新打包&#13;
find . | cpio -oH newc | xz --check=crc32 -9 &gt; ../initrd.img&#13;
&#13;
cpio -H参数说明：&#13;
* bin 过时的二进制格式。</description><guid isPermaLink="true">https://longxiucai.github.io/post/lin-shi-xiu-gai-initrd.img.html</guid><pubDate>Tue, 02 Jul 2024 05:40:28 +0000</pubDate></item><item><title>正则表达式</title><link>https://longxiucai.github.io/post/zheng-ze-biao-da-shi.html</link><description>## 元字符说明&#13;
&#13;
    元字符:  |&#13;
    匹配规则:匹配|两边任意一个正则表达式&#13;
&#13;
    元字符:  .&#13;
    匹配规则:匹配除换行外的任意字符&#13;
&#13;
    元字符:  ^&#13;
    匹配规则:匹配目标字符串的开头位置&#13;
&#13;
    元字符:  $&#13;
    匹配规则:匹配字符串的结束位置&#13;
&#13;
    元字符:  *&#13;
    匹配规则:匹配前面的字符出现0次或多次&#13;
&#13;
    元字符:  +&#13;
    匹配规则:匹配前面的字符出现一次或多次&#13;
&#13;
	元字符:  ?&#13;
	匹配规则:匹配前面的字符出现0次或1次&#13;
&#13;
    元字符:  {n}&#13;
    匹配规则:匹配指定的重复次数&#13;
   &#13;
	 元字符: {m,n}   &#13;
    匹配规则:匹配前面的正则表达式 m--n次        &#13;
&#13;
&#13;
## 匹配字符集合&#13;
&#13;
* 元字符:`[字符集]`&#13;
&#13;
    匹配规则:匹配任意一个字符集下的字符&#13;
```&#13;
    [abc123] a b c 1 2 3 12 &#13;
	[a-z] [0-9] [_123a-z]&#13;
    eg:&#13;
    &gt;&gt;&gt; re.findall('^[a-z][a-z]','boy')&#13;
    ['bo']&#13;
```&#13;
* 元字符:`[^...]`&#13;
&#13;
    匹配规则:字符集取非,除了列出的字符之外任意一个字符&#13;
```&#13;
    [^abc]--&gt;除abc之外任意字符&#13;
    eg:&#13;
    &gt;&gt;&gt; re.findall('[^abcds]','boyadshfhjasjhbhjasf')&#13;
    ['o', 'y', 'h', 'f', 'h', 'j', 'j', 'h', 'h', 'j', 'f']&#13;
```&#13;
&#13;
* 元字符: `\d`  `\D`&#13;
&#13;
    匹配规则: &#13;
&#13;
    `\d` 匹配任意数字字符      [0-9]&#13;
    &#13;
    `\D` 匹配任意非数字字符    [^0-9]&#13;
```&#13;
    eg:&#13;
    &gt;&gt;&gt; re.findall('\D','AID1807')&#13;
    ['A', 'I', 'D']&#13;
&#13;
	\1,\2	反向引用	匹配之前第一、第二括号内表达式匹配的内容&#13;
&#13;
	举个例子，想找到连续两个重复单词，我们就必须要知道前面单词是什么，这时候就可以使用反向引用了，可以简单写为(\w+)\s+\1&#13;
```&#13;
	&#13;
* 元字符:`\w`  `\W`&#13;
    匹配规则:&#13;
&#13;
    `\w` 普通字符  &#13;
    &#13;
    `\W` 非普通字符&#13;
```&#13;
    eg:&#13;
    &gt;&gt;&gt; re.findall('\w','我在北京')&#13;
    ['我', '在', '北', '京']&#13;
            &#13;
    &gt;&gt;&gt; re.findall('\W','!@#$我在北京')&#13;
    ['!', '@', '#', '$']&#13;
```&#13;
&#13;
* 元字符: `\s` `\S`&#13;
    匹配规则:&#13;
&#13;
    `\s` 匹配任意空字符`[\r\t\n\v\f]`&#13;
&#13;
    `\S` 匹配任意非空字符&#13;
```&#13;
    eg:&#13;
    &gt;&gt;&gt; re.findall('\w+\s+\w+','hello     beijin')&#13;
    ['hello     beijin']&#13;
    &gt;&gt;&gt; re.findall('\w+\S+\w+','hello     beijin')&#13;
    ['hello', 'beijin']&#13;
```&#13;
* 元字符: `\A` `\Z`&#13;
   &#13;
    匹配规则:&#13;
    &#13;
    `\A` 匹配字符串开头位置  `^`&#13;
&#13;
    `\Z` 匹配字符串结尾位置  `$`&#13;
```&#13;
    &gt;&gt;&gt; re.findall('\Ahello','hellobeijin')&#13;
    ['hello']&#13;
    &gt;&gt;&gt; re.findall('beijin\Z','hellobeijin')&#13;
    ['beijin']&#13;
```&#13;
绝对匹配:正则表达式完全匹配目标字符串内容&#13;
&#13;
在正则表达式的开头或者结尾加上`^`或者`$`(或者`\A` `\Z`).这样正则表达式必须匹配到整个目标字符串才会有结果&#13;
```&#13;
    eg:&#13;
    &gt;&gt;&gt; re.findall('\A\d+$','1234568789')&#13;
    ['1234568789']&#13;
&#13;
    匹配(非)单词边界&#13;
    \&lt;	单词分界符	匹配单词开始	java中使用\b&#13;
	\&gt;	单词分界符	匹配单词结束	java中使用\B&#13;
```&#13;
* 元字符: `\b` `\B`&#13;
    &#13;
    匹配规则:&#13;
    &#13;
    `\b` 匹配单词边界位置&#13;
&#13;
    `\B` 匹配非单词边界位置&#13;
            普通字符和非普通字符认为是单词边界&#13;
```&#13;
    eg:&#13;
    &gt;&gt;&gt; re.findall(r'he\b','he ##is a good gril')&#13;
    ['he']&#13;
```&#13;
 &#13;
## 元字符总结&#13;
&#13;
匹配单个字符: &#13;
```&#13;
a  .  \d   \D  \s  \S  \w   \W  [...]  [^...]&#13;
```&#13;
匹配重复: &#13;
```&#13;
*  +  ?  {n}  {m,n}&#13;
```&#13;
匹配位置:&#13;
```&#13;
^  $  \A  \Z  \b  \B&#13;
```&#13;
其他: &#13;
```&#13;
|  ()  \&#13;
```&#13;
## 正则表达式转义&#13;
&#13;
正则中的特殊字符&#13;
```&#13;
. * + ? ^ $ [] {} () | \&#13;
```&#13;
正则表达式如果匹配特殊字符需要加`\`表达转义&#13;
```&#13;
    eg:             正则  目标字符串&#13;
    &gt;&gt;&gt; re.findall('\$\d+','$10')&#13;
    ['$10']&#13;
&#13;
             pattern     string&#13;
    python  '\\$\\d+'     '$10'&#13;
    python   r'\$\d+'     '$10'&#13;
&#13;
    raw子串: 原始字符串对内容不解释转义,就表达内容原本的意义&#13;
```&#13;
## 贪婪和非贪婪&#13;
&#13;
贪婪模式:正则表达式的重复匹配总是尽可能多的向后匹配更多内容`* + ? {m,n}`&#13;
&#13;
非贪婪模式(懒惰模式):尽可能少的匹配内容&#13;
```&#13;
    贪婪---&gt;非贪婪 *?  +?  ??   {m,n}?&#13;
    &gt;&gt;&gt; re.findall(r'ab','abbbbbbbbbbb')&#13;
    ['ab']&#13;
    &#13;
    &gt;&gt;&gt; re.findall(r'ab+','abbbbbbbbbbb')&#13;
    ['abbbbbbbbbbb']&#13;
    &#13;
    &gt;&gt;&gt; re.findall(r'ab{3,5}?','abbbbbbbbbbb')&#13;
    ['abbb']&#13;
```&#13;
## 正则表达式的子组&#13;
可以使用()为正则表达式建立子组,子组可以看做是正则表达式内部操作的一个整体&#13;
&#13;
子组是在正则表达式整体匹配到内容的前提下才会发挥的作用,他不影响正则表达式整体去匹配目标内容这一原则&#13;
&#13;
子组作用&#13;
&#13;
1.作为内部整体可以改变某些原字符的行为&#13;
    eg:&#13;
    &gt;&gt;&gt; re.search(r'(ab)+\d+','abababab123456').group()&#13;
    'abababab123456'&#13;
&#13;
2.子组在某些操作中可以单独提取出匹配内容&#13;
    &gt;&gt;&gt; re.search(r'(https|http|ftp)://\S+','https://baidu.com').group()&#13;
    'https://baidu.com'&#13;
&#13;
&#13;
子组使用注意事项:&#13;
* 一个正则表达式中可以有多个子组&#13;
* 子组一般由外到内,左到右称之为第一,第二,第三...子组&#13;
* 子组不能重叠,嵌套也不宜很复杂&#13;
&#13;
&#13;
## 捕获组和非捕获组&#13;
&#13;
格式:&#13;
```&#13;
(?P&lt;name&gt;pattern)&#13;
&#13;
&gt;&gt;&gt; re.search(r'(?P&lt;dog&gt;ab)cdef','abcdefghijklmn').group('dog')&#13;
'ab'&#13;
```&#13;
作用:可以通过组名更方便获取某组内容。</description><guid isPermaLink="true">https://longxiucai.github.io/post/zheng-ze-biao-da-shi.html</guid><pubDate>Tue, 02 Jul 2024 05:36:57 +0000</pubDate></item><item><title>修改pod网段与calico配置</title><link>https://longxiucai.github.io/post/xiu-gai-pod-wang-duan-yu-calico-pei-zhi.html</link><description>1. vim /etc/kubernetes/manifests/kube-controller-manager.yaml 【3个master一个一个的执行，最好是kube-controller-manager-节点名字的pod Running之后再修改下一个节点】&#13;
		19行：--cluster-cidr=10.128.0.0/18&#13;
&#13;
2. kubectl edit cm kubeadm-config -n kube-system&#13;
		podSubnet: 10.128.0.0/18&#13;
&#13;
3. kubectl edit cm kube-proxy -n kube-system&#13;
		clusterCIDR: 10.128.0.0/18&#13;
&#13;
4. kubectl edit ippool default-ipv4-ippool&#13;
		cidr: 10.128.0.0/18&#13;
&#13;
5. kubectl edit cm calico-config -n kube-system ：&#13;
          'ipam': {&#13;
              'type': 'calico-ipam',					              #逗号&#13;
              'ipv4_pools': ['default-ipv4-ippool']   #添加此行，前面必须是空格不能是tab&#13;
          },&#13;
&#13;
6. kubectl rollout restart -n kube-system daemonset.apps/calico-node&#13;
等待calico的pod全部running，全部节点查看配置文件是否有'ipv4_pools': ['default-ipv4-ippool']：&#13;
cat /etc/cni/net.d/00-multus.conf&#13;
cat /etc/cni/net.d/10-calico.conflist&#13;
&#13;
7. kubectl  edit ippool kubevirt-vm-ippool&#13;
  cidr: 10.128.128.0/18&#13;
&#13;
8. kubectl delete ippool other-ippool&#13;
&#13;
9. kubectl cluster-info dump | grep cluster-cidr&#13;
&#13;
&#13;
默认使用default pool，开启noipam功能&#13;
calico-config configMap:&#13;
cni.projectcalico.org/ipAddrsNoIpam&#13;
```&#13;
apiVersion: v1&#13;
data:&#13;
  calico_backend: bird&#13;
  cni_network_config: |-&#13;
    {&#13;
      'name': 'k8s-pod-network',&#13;
      'cniVersion': '0.3.1',&#13;
      'plugins': [&#13;
        {&#13;
          'type': 'calico',&#13;
          'log_level': 'info',&#13;
          'log_file_path': '/var/log/calico/cni/cni.log',&#13;
          'datastore_type': 'kubernetes',&#13;
          'nodename': '__KUBERNETES_NODE_NAME__',&#13;
          'mtu': __CNI_MTU__,&#13;
          'ipam': {&#13;
              'type': 'calico-ipam',&#13;
              'ipv4_pools': ['default-ipv4-ippool']&#13;
          },&#13;
          'policy': {&#13;
              'type': 'k8s'&#13;
          },&#13;
          'kubernetes': {&#13;
              'kubeconfig': '__KUBECONFIG_FILEPATH__'&#13;
          },&#13;
         'feature_control': {&#13;
             'ip_addrs_no_ipam': true&#13;
         }&#13;
        },&#13;
        {&#13;
          'type': 'portmap',&#13;
          'snat': true,&#13;
          'capabilities': {'portMappings': true}&#13;
        },&#13;
        {&#13;
          'type': 'bandwidth',&#13;
          'capabilities': {'bandwidth': true}&#13;
        }&#13;
      ]&#13;
    }&#13;
  typha_service_name: none&#13;
  veth_mtu: '0'&#13;
kind: ConfigMap&#13;
metadata:&#13;
  name: calico-config&#13;
  namespace: kube-system&#13;
```&#13;
&#13;
。</description><guid isPermaLink="true">https://longxiucai.github.io/post/xiu-gai-pod-wang-duan-yu-calico-pei-zhi.html</guid><pubDate>Tue, 02 Jul 2024 03:23:13 +0000</pubDate></item><item><title>go解析证书文件</title><link>https://longxiucai.github.io/post/go-jie-xi-zheng-shu-wen-jian.html</link><description>```&#13;
package cert&#13;
&#13;
import (&#13;
	'crypto/x509'&#13;
	'encoding/pem'&#13;
	'os'&#13;
	'path/filepath'&#13;
	'strings'&#13;
	'time'&#13;
&#13;
	log 'github.com/sirupsen/logrus'&#13;
)&#13;
&#13;
func parseCertificate(file string) {&#13;
	// 读取文件内容&#13;
	fileData, err := os.ReadFile(file)&#13;
	if err != nil {&#13;
		log.Errorf('Error reading file %s: %s\n', file, err)&#13;
		return&#13;
	}&#13;
&#13;
	// 解析 PEM 块&#13;
	block, _ := pem.Decode(fileData)&#13;
	if block == nil {&#13;
		log.Errorf('No PEM block found in file %s\n', file)&#13;
		return&#13;
	}&#13;
&#13;
	// 判断文件类型&#13;
	fileType := strings.ToLower(filepath.Ext(file))&#13;
	switch fileType {&#13;
	case '.crt', '.pem':&#13;
		// 解析证书&#13;
		cert, err := x509.ParseCertificate(block.Bytes)&#13;
		if err != nil {&#13;
			log.Errorf('Error parsing certificate from file %s: %s\n', file, err)&#13;
			return&#13;
		}&#13;
&#13;
		// 输出证书有效期等信息&#13;
		log.Infof('Certificate in file %s:', file)&#13;
		log.Infof('  Subject: %s', cert.Subject.CommonName)&#13;
		log.Infof('  Valid from: %s', cert.NotBefore)&#13;
		log.Infof('  Valid until: %s', cert.NotAfter)&#13;
&#13;
		// 计算证书有效期结束时间与当前时间之间的天数差&#13;
		now := time.Now()&#13;
		expiresInDays := int((time.Duration(cert.NotAfter.Sub(now).Hours()) / 24))&#13;
		log.Infof('证书%s 将于 %d 天后过期', cert.Subject.CommonName, expiresInDays)&#13;
		log.Infof('---------------------------')&#13;
	default:&#13;
		log.Infof('Unsupported file type: %s %s', fileType, file)&#13;
	}&#13;
}&#13;
```。</description><guid isPermaLink="true">https://longxiucai.github.io/post/go-jie-xi-zheng-shu-wen-jian.html</guid><pubDate>Tue, 02 Jul 2024 02:33:15 +0000</pubDate></item><item><title>go连接数据库</title><link>https://longxiucai.github.io/post/go-lian-jie-shu-ju-ku.html</link><description>```&#13;
package dbtest&#13;
&#13;
import (&#13;
	'database/sql'&#13;
	'fmt'&#13;
	'log'&#13;
&#13;
	_ 'github.com/go-sql-driver/mysql'&#13;
)&#13;
&#13;
func maindb() {&#13;
	// 连接 MySQL 数据库&#13;
	db, err := sql.Open('mysql', 'dbinit:123456@tcp(10.42.186.232:3306)/dbinit_test')&#13;
	if err != nil {&#13;
		log.Fatal(err)&#13;
	}&#13;
	defer db.Close()&#13;
&#13;
	// 测试连接&#13;
	err = db.Ping()&#13;
	if err != nil {&#13;
		log.Fatal('Error connecting to the database:', err)&#13;
	}&#13;
&#13;
	fmt.Println('Connected to MySQL database successfully!')&#13;
&#13;
	// 查询示例&#13;
	rows, err := db.Query('SELECT * FROM users')&#13;
	if err != nil {&#13;
		log.Fatal('Error executing query:', err)&#13;
	}&#13;
	defer rows.Close()&#13;
&#13;
	// 遍历查询结果&#13;
	for rows.Next() {&#13;
		var id int&#13;
		var name string&#13;
		err := rows.Scan(&amp;id, &amp;name)&#13;
		if err != nil {&#13;
			log.Fatal('Error scanning row:', err)&#13;
		}&#13;
		fmt.Printf('ID: %d, Name: %s\n', id, name)&#13;
	}&#13;
}&#13;
```。</description><guid isPermaLink="true">https://longxiucai.github.io/post/go-lian-jie-shu-ju-ku.html</guid><pubDate>Tue, 02 Jul 2024 02:04:36 +0000</pubDate></item></channel></rss>
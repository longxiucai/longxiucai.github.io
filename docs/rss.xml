<?xml version='1.0' encoding='UTF-8'?>
<rss xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0"><channel><title>龙宇翔的小本本</title><link>https://longxiucai.github.io</link><description> </description><copyright>龙宇翔的小本本</copyright><docs>http://www.rssboard.org/rss-specification</docs><generator>python-feedgen</generator><image><url>https://avatars.githubusercontent.com/u/43312586</url><title>avatar</title><link>https://longxiucai.github.io</link></image><lastBuildDate>Fri, 26 Jul 2024 03:34:19 +0000</lastBuildDate><managingEditor>龙宇翔的小本本</managingEditor><ttl>60</ttl><webMaster>龙宇翔的小本本</webMaster><item><title>linux修改密码与系统救援</title><link>https://longxiucai.github.io/post/linux-xiu-gai-mi-ma-yu-xi-tong-jiu-yuan.html</link><description>## 需要iso来当本地yum源的需提前添加cd-rom并选择好对应的iso文件&#13;
![](https://github.com/user-attachments/assets/b6940c91-1798-4f32-aa79-2d2b59bf371d)&#13;
&#13;
## 重启之后在grub界面按`e`&#13;
![](https://github.com/user-attachments/assets/fe06fe3f-5a37-4176-ad5c-ae4e55a2d665)&#13;
&#13;
## 找到如下行，并且删除圈出来的部分&#13;
找到`linux`开头的行，删除`ro`与`rhgb`，rhgb不删除可能会报错无法进入救援模式&#13;
![](https://github.com/user-attachments/assets/629f57e0-482e-4499-a04c-fef6f450c1be)&#13;
&#13;
## 增加圈出来的部分，ctrl+x进入救援模式，不需要root密码&#13;
增加`rw init=/bin/bash console=tty0`&#13;
![](https://github.com/user-attachments/assets/58e7d784-0b96-4604-9483-26a5c6181faa)&#13;
&#13;
## 救援模式下查看cd-rom为/dev/sr0，挂载之后可以当做本地yum源，用于还原包的版本。</description><guid isPermaLink="true">https://longxiucai.github.io/post/linux-xiu-gai-mi-ma-yu-xi-tong-jiu-yuan.html</guid><pubDate>Fri, 26 Jul 2024 03:26:33 +0000</pubDate></item><item><title>在线可视化正则表达式</title><link>https://longxiucai.github.io/post/zai-xian-ke-shi-hua-zheng-ze-biao-da-shi.html</link><description># 原项目&#13;
https://github.com/gskinner/regexr/&#13;
https://regexr.com/&#13;
&#13;
# 中文翻译项目&#13;
http://github.com/skys215/regexr/&#13;
https://regexr-cn.com/。</description><guid isPermaLink="true">https://longxiucai.github.io/post/zai-xian-ke-shi-hua-zheng-ze-biao-da-shi.html</guid><pubDate>Tue, 23 Jul 2024 01:45:51 +0000</pubDate></item><item><title>记录一次pod网络问题，dns min参数对网络影响</title><link>https://longxiucai.github.io/post/ji-lu-yi-ci-pod-wang-luo-wen-ti-%EF%BC%8Cdns%20min-can-shu-dui-wang-luo-ying-xiang.html</link><description>## 问题现象&#13;
容器内执行程序报错，程序需要连接指定的svc&#13;
![现象](https://github.com/user-attachments/assets/6eaf7525-06c1-4b75-b0b3-e042572224e2)&#13;
&#13;
## 网络排查&#13;
1、pod内nslookup能够解析出正确的ip地址，coredns没问题&#13;
![](https://github.com/user-attachments/assets/4d683d92-ee8e-4e56-954c-09b8e807cd74)&#13;
&#13;
2、pod内ping有报错&#13;
![微信图片_20240723091634](https://github.com/user-attachments/assets/e3e91ad8-ad37-41ec-b5bf-ef7b13e0a264)&#13;
&#13;
3、手动修改容器内/etc/hosts，程序执行没问题&#13;
![](https://github.com/user-attachments/assets/439151cb-dcbd-4a75-8976-6ded8d055c3c)&#13;
&#13;
4、查看容器内/etc/resolv.conf,发现末尾有min字段&#13;
![](https://github.com/user-attachments/assets/3fd3e5bd-37fc-4ec4-86ec-0fec5b70bb4d)&#13;
&#13;
5、修改去除min字段，删除/etc/hosts解析，程序没问题&#13;
![](https://github.com/user-attachments/assets/13379954-03ee-4f54-aa60-0e19d26c24b2)&#13;
&#13;
## 配置排查&#13;
1、查看pod的dns解析策略，没问题&#13;
![](https://github.com/user-attachments/assets/d6b1ae96-715d-433f-a215-e5daad117c5a)&#13;
&#13;
2、查看coredns配置，没问题&#13;
![](https://github.com/user-attachments/assets/12d44482-6545-4974-b86d-3ac9eacefac9)&#13;
&#13;
3、查看宿主机/etc/resolv.conf，有min字段&#13;
![](https://github.com/user-attachments/assets/537a3892-5fcc-440d-9852-a815212bdfa4)&#13;
&#13;
## 解决方法&#13;
宿主机/etc/resolv.conf删除min字段之后，pod删除重新拉起，容器恢复正常。</description><guid isPermaLink="true">https://longxiucai.github.io/post/ji-lu-yi-ci-pod-wang-luo-wen-ti-%EF%BC%8Cdns%20min-can-shu-dui-wang-luo-ying-xiang.html</guid><pubDate>Tue, 23 Jul 2024 01:35:38 +0000</pubDate></item><item><title>MarkDown语法</title><link>https://longxiucai.github.io/post/MarkDown-yu-fa.html</link><description>README&#13;
===========================&#13;
&#13;
该文件用来测试和展示书写README的各种markdown语法。</description><guid isPermaLink="true">https://longxiucai.github.io/post/MarkDown-yu-fa.html</guid><pubDate>Mon, 22 Jul 2024 03:03:31 +0000</pubDate></item><item><title>Markdown emoji</title><link>https://longxiucai.github.io/post/Markdown%20emoji.html</link><description>Emoji表情&#13;
=========&#13;
将对应emoji表情的符号码复制后输入你的markdown文本即可显示emoji表情。</description><guid isPermaLink="true">https://longxiucai.github.io/post/Markdown%20emoji.html</guid><pubDate>Mon, 22 Jul 2024 01:55:06 +0000</pubDate></item><item><title>排序算法详解</title><link>https://longxiucai.github.io/post/pai-xu-suan-fa-xiang-jie.html</link><description># 复杂度&#13;
&#13;
| 排序方法  | 时间复杂度（平均） | 时间复杂度（最坏） | 时间复杂度（最好） | 空间复杂度 | 稳定性 |&#13;
| -------- | ------------------ | ------------------ | ------------------ | ---------- | ------ |&#13;
| 插入排序 | O(n^2)             | O(n^2)             | O(n)               | O(1)       | 稳定   |&#13;
| 希尔排序 | O(n^1.3)           | O(n^2)             | O(n)               | O(1)       | 不稳定 |&#13;
| 选择排序 | O(n^2)             | O(n^2)             | O(n^2)             | O(1)       | 不稳定 |&#13;
| 堆排序   | O(nlog₂n)          | O(nlog₂n)          | O(nlog₂n)          | O(1)       | 不稳定 |&#13;
| 冒泡排序 | O(n^2)             | O(n^2)             | O(n)               | O(1)       | 稳定   |&#13;
| 快速排序 | O(nlog₂n)          | O(n^2)             | O(nlog₂n)          | O(nlog₂n)  | 不稳定 |&#13;
| 归并排序 | O(nlog₂n)          | O(nlog₂n)          | O(nlog₂n)          | O(n)       | 稳定   |&#13;
&#13;
# 排序算法详解&#13;
## 一、直接插入（Insertion Sort）&#13;
插入排序（Insertion-Sort）的算法描述是一种简单直观的排序算法。</description><guid isPermaLink="true">https://longxiucai.github.io/post/pai-xu-suan-fa-xiang-jie.html</guid><pubDate>Fri, 19 Jul 2024 08:24:08 +0000</pubDate></item><item><title>pod的创建流程</title><link>https://longxiucai.github.io/post/pod-de-chuang-jian-liu-cheng.html</link><description># 详细步骤&#13;
1. **用户提交高级资源定义**：通过 kubectl apply -f deployment.yaml 或 API 请求来提交 Deployment、ReplicaSet 等高级资源定义。</description><guid isPermaLink="true">https://longxiucai.github.io/post/pod-de-chuang-jian-liu-cheng.html</guid><pubDate>Fri, 19 Jul 2024 07:30:59 +0000</pubDate></item><item><title>systemd-exporter指标说明</title><link>https://longxiucai.github.io/post/systemd-exporter-zhi-biao-shuo-ming.html</link><description>指标名称|描述|	来源|	是否需要添加运行参数&#13;
--------- | --------|--------|--------|&#13;
systemd_process_open_fds|	Number of open file descriptors	|/proc/&lt;pid&gt;/fd/*   数量|	--systemd.collector.enable-file-descriptor-size&#13;
systemd_service_ip_egress_bytes|	Service unit egress IP accounting in bytes	|dbus Service类型 IPEgressBytes属性	|--systemd.collector.enable-ip-accounting&#13;
systemd_service_ip_egress_packets_total|	Service unit egress IP accounting in packets|	dbus Service类型 IPEgressPackets属性|--systemd.collector.enable-ip-accounting&#13;
systemd_service_ip_ingress_bytes|	Service unit ingress IP accounting in bytes|	dbus Service类型 IPIngressBytes属性|--systemd.collector.enable-ip-accounting&#13;
systemd_service_ip_ingress_packets_total|	Service unit ingress IP accounting in packets|	dbus Service类型 IPIngressPackets属性|--systemd.collector.enable-ip-accounting&#13;
systemd_service_restart_total|	Service unit count of Restart triggers|	dbus Service类型 NRestarts属性|	--systemd.collector.enable-restart-count&#13;
systemd_exporter_build_info|	A metric with a constant '1' value labeled by version, revision, branch, and goversion from which systemd_exporter was built.	|| 否&#13;
systemd_process_cpu_seconds_total|	Total user and system CPU time spent in seconds|	/proc/&lt;pid&gt;/stat中第14与15个值的和再除以100	|否&#13;
systemd_process_max_fds|	Maximum number of open file descriptors	| /proc/&lt;pid&gt;/limits中‘Max open files’的‘Soft Limit’值	|否&#13;
systemd_process_resident_memory_bytes|	Resident memory size in bytes|	/proc/&lt;pid&gt;/stat中第24个值乘pagesize	|否&#13;
systemd_process_virtual_memory_bytes|	Virtual memory size in bytes|	/proc/&lt;pid&gt;/stat中第23个值	|否&#13;
systemd_process_virtual_memory_max_bytes|	Maximum amount of virtual memory available in bytes|	/proc/&lt;pid&gt;/limits中‘Max address space’的‘Soft Limit’值	|否&#13;
systemd_socket_accepted_connections_total|	Total number of accepted socket connections|	dbus Service类型 NAccepted属性	|否&#13;
systemd_socket_current_connections|	Current number of socket connections|	dbus Service类型 NConnections属性	|否&#13;
systemd_socket_refused_connections_total|	Total number of refused socket connections|	dbus Service类型 NRefused属性	|否&#13;
systemd_timer_last_trigger_seconds|	Seconds since epoch of last trigger.|	dbus Timer类型 LastTriggerUSec属性再除以1e6	|否&#13;
systemd_unit_cpu_seconds_total|	Unit CPU time in seconds|	cgroup中的cpuacct.usage_all	|否&#13;
systemd_unit_info|	Mostly-static metadata for all unit types|	dbus Service类型 Type属性、servicename	|否&#13;
systemd_unit_start_time_seconds|	Start time of the unit since unix epoch in seconds|	dbus Service类型 ActiveEnterTimestamp属性再除以1e6	|否&#13;
systemd_unit_state|	Systemd unit|	dbus连接获取服务列表时的值	|否&#13;
systemd_unit_tasks_current|	Current number of tasks per Systemd unit|	dbus Service类型 TasksCurrent属性	|否&#13;
systemd_unit_tasks_max|	Maximum number of tasks per Systemd unit|	dbus Service类型 TasksMax属性	|否。</description><guid isPermaLink="true">https://longxiucai.github.io/post/systemd-exporter-zhi-biao-shuo-ming.html</guid><pubDate>Tue, 16 Jul 2024 07:56:23 +0000</pubDate></item><item><title>日志工具vector自定义日志解析与过滤，包含vrl语法解释与http后端demo（go编写）</title><link>https://longxiucai.github.io/post/ri-zhi-gong-ju-vector-zi-ding-yi-ri-zhi-jie-xi-yu-guo-lv-%EF%BC%8C-bao-han-vrl-yu-fa-jie-shi-yu-http-hou-duan-demo%EF%BC%88go-bian-xie-%EF%BC%89.html</link><description>源码：https://github.com/vectordotdev/vector&#13;
&#13;
helm repo:   https://helm.vector.dev/&#13;
&#13;
repo chart: https://github.com/vectordotdev/helm-charts/tree/develop&#13;
&#13;
文档： https://vector.dev/docs/&#13;
&#13;
# 验证与测试方法&#13;
1、当前目录中创建vector.yaml文件，文件名必须为vector.yaml&#13;
2、执行命令验证&#13;
```&#13;
alias vector='nerdctl run -it -v $(pwd)/:/etc/vector/ -v /var/log/:/var/log/ --rm harbor.kylincloudnative.com/docker.io/timberio/vector:0.39.0-alpine'&#13;
nerdctl pull harbor.kylincloudnative.com/docker.io/timberio/vector:0.39.0-alpine&#13;
vector&#13;
```&#13;
# ingress-controller日志示例(/var/log/test-pod-log-ingress)&#13;
```&#13;
2024-07-15T14:28:37+08:00       error   ingress/controller.go:653       upstream is not referenced      {'cluster': 'name=default; base_url=http://apisix-admin.apisix-system:9180/apisix/admin', 'upstream': 'default_kubelet_10250'}&#13;
2024-07-15T14:28:37+08:00       error   ingress/controller.go:653       upstream is not referenced      {'cluster': 'name=default; base_url=http://apisix-admin.apisix-system:9180/apisix/admin', 'upstream': 'default_kubelet_10250'}&#13;
2024-07-15T14:28:37+08:00       warn    ingress/controller.go:653       upstream is not referenced      {'cluster': 'name=default; base_url=http://apisix-admin.apisix-system:9180/apisix/admin', 'upstream': 'default_kubelet_10255'}&#13;
2024-07-15T14:28:37+08:00       warn    ingress/controller.go:653       upstream is not referenced      {'cluster': 'name=default; base_url=http://apisix-admin.apisix-system:9180/apisix/admin', 'upstream': 'default_kubelet_4194'}&#13;
2024-07-15T14:28:38+08:00       error   ingress/controller.go:653       upstream is not referenced      {'cluster': 'name=default; base_url=http://apisix-admin.apisix-system:9180/apisix/admin', 'upstream': 'default_kubelet_10250'}&#13;
2024-07-15T14:28:38+08:00       warn    ingress/controller.go:653       upstream is not referenced      {'cluster': 'name=default; base_url=http://apisix-admin.apisix-system:9180/apisix/admin', 'upstream': 'default_kubelet_10255'}&#13;
2024-07-15T14:28:38+08:00       warn    ingress/controller.go:653       upstream is not referenced      {'cluster': 'name=default; base_url=http://apisix-admin.apisix-system:9180/apisix/admin', 'upstream': 'default_kubelet_4194'}&#13;
```&#13;
# vector.yaml配置&#13;
```&#13;
api:&#13;
  enabled: true&#13;
  address: 127.0.0.1:58686&#13;
  playground: false&#13;
sources:&#13;
  ingress:&#13;
    type: file&#13;
    include: &#13;
      - /var/log/test-pod-log-ingress&#13;
    data_dir: /etc/vector/workdir&#13;
transforms:&#13;
  parse_ingress:&#13;
    inputs:&#13;
      - ingress&#13;
    type: remap&#13;
    source: |&#13;
      . |= parse_regex!(.message, r'^(?P&lt;timestamp&gt;\d+-\d+-\d+T\d+:\d+:\d+\+\d+:\d+)\s+(?P&lt;log_level&gt;\w+)\s+(?P&lt;file_path&gt;[\w./:-]+)\s+(?P&lt;message&gt;[^\{]+)\s+(?P&lt;structured_data&gt;\{.*\})$')&#13;
      .structured_data = parse_json!(.structured_data)&#13;
      .structured_data = parse_key_value!(.structured_data.cluster, key_value_delimiter: '=' )&#13;
      . = merge(., .structured_data)&#13;
      del(.structured_data)&#13;
  ingress_filter:&#13;
    type: filter&#13;
    inputs:&#13;
      - parse_ingress&#13;
    condition:&#13;
      type: vrl&#13;
      source: .log_level == 'error'&#13;
sinks:&#13;
  http_log:&#13;
    inputs:&#13;
      - ingress_filter&#13;
    uri: http://10.42.16.241:8080/push&#13;
    type: http&#13;
    encoding:&#13;
      codec: json&#13;
  console_log:&#13;
    inputs:&#13;
      - parse_ingress&#13;
    type: console&#13;
    encoding:&#13;
      codec: json&#13;
```&#13;
## sources配置说明&#13;
直接从文件读取日志&#13;
## transforms配置说明&#13;
1、**parse_ingress**使用正则表达式解析日志的timestamp、log_level、file_path、message、structured_data，然后将structured_data再次通过key-value的方式解析。</description><guid isPermaLink="true">https://longxiucai.github.io/post/ri-zhi-gong-ju-vector-zi-ding-yi-ri-zhi-jie-xi-yu-guo-lv-%EF%BC%8C-bao-han-vrl-yu-fa-jie-shi-yu-http-hou-duan-demo%EF%BC%88go-bian-xie-%EF%BC%89.html</guid><pubDate>Mon, 15 Jul 2024 08:13:10 +0000</pubDate></item><item><title>docker desktop登录报错Error saving credentials</title><link>https://longxiucai.github.io/post/docker%20desktop-deng-lu-bao-cuo-Error%20saving%20credentials.html</link><description>报错内容具体为：&#13;
```&#13;
$ docker login harbor.xxx.com/docker.io/timberio/vector:0.39.0-alpine-arm64&#13;
Username: admin&#13;
Password: &#13;
Error saving credentials: error storing credentials - err: exit status 1, out: `error getting credentials - err: exit status 1, out: `no usernames for harbor.xxx.com``&#13;
```&#13;
解决方案：修改~/.docker/config.json删除`'credsStore': 'desktop',`，然后重新启动。</description><guid isPermaLink="true">https://longxiucai.github.io/post/docker%20desktop-deng-lu-bao-cuo-Error%20saving%20credentials.html</guid><pubDate>Thu, 11 Jul 2024 09:12:09 +0000</pubDate></item><item><title>docker配置代理</title><link>https://longxiucai.github.io/post/docker-pei-zhi-dai-li.html</link><description># rpm装的docker，且服务器没有外网&#13;
1. 修改/usr/lib/systemd/system/docker.service文件(有的可能不是这个文件。</description><guid isPermaLink="true">https://longxiucai.github.io/post/docker-pei-zhi-dai-li.html</guid><pubDate>Thu, 11 Jul 2024 09:08:39 +0000</pubDate></item><item><title>docker manifest合并不同架构镜像push</title><link>https://longxiucai.github.io/post/docker%20manifest-he-bing-bu-tong-jia-gou-jing-xiang-push.html</link><description>1、镜像仓库中有2个架构的镜像且tag不一致，没有则push上去&#13;
```&#13;
docker push  harbor.yourharbor.com/docker.io/timberio/vector:0.39.0-alpine-arm64&#13;
docker push  harbor.yourharbor.com/docker.io/timberio/vector:0.39.0-alpine-amd64&#13;
```&#13;
2、创建manifest&#13;
```&#13;
docker manifest create harbor.yourharbor.com/docker.io/timberio/vector:0.39.0-alpine \&#13;
--amend harbor.yourharbor.com/docker.io/timberio/vector:0.39.0-alpine-amd64 \&#13;
--amend harbor.yourharbor.com/docker.io/timberio/vector:0.39.0-alpine-arm64&#13;
```&#13;
3、push manifest&#13;
```&#13;
 docker manifest push harbor.yourharbor.com/docker.io/timberio/vector:0.39.0-alpine   &#13;
```。</description><guid isPermaLink="true">https://longxiucai.github.io/post/docker%20manifest-he-bing-bu-tong-jia-gou-jing-xiang-push.html</guid><pubDate>Thu, 11 Jul 2024 09:00:21 +0000</pubDate></item><item><title>redis一主一从集群脑裂现象模拟</title><link>https://longxiucai.github.io/post/redis-yi-zhu-yi-cong-ji-qun-nao-lie-xian-xiang-mo-ni.html</link><description># 一主一从redis脑裂现象模拟&#13;
主节点A:10.42.186.32  从节点B:10.42.186.33&#13;
&#13;
1. 网络隔离&#13;
```bash&#13;
# 10.42.186.32 执行下面命令&#13;
iptables -A INPUT -s 10.42.186.33 -j DROP&#13;
iptables -A OUTPUT -d 10.42.186.33 -j DROP&#13;
&#13;
# 10.42.186.33 执行下面命令&#13;
iptables -A INPUT -s 10.42.186.32 -j DROP&#13;
iptables -A OUTPUT -d 10.42.186.32 -j DROP&#13;
```&#13;
&#13;
2. 从节点升级为主节点&#13;
```bash&#13;
redis-cli -h 10.42.186.33 -p 6379 -a Kylin.2023! cluster failover takeover&#13;
```&#13;
3. 查看集群状态(此时2个节点都是主节点)&#13;
```bash&#13;
# redis-cli -h 10.42.186.32 -p 6379 -a Kylin.2023! cluster nodes&#13;
4226cce5d7735c488a74e3aff86ad641d5c5e54b 10.42.186.33:6379@16379 master,fail? - 1719909668692 1719909667688 1 connected&#13;
b4519db09c96d8ad12efae818210e6521525e2bf 10.42.186.32:6379@16379 myself,master - 0 0 2 connected 0-16383&#13;
&#13;
# redis-cli -h 10.42.186.33 -p 6379 -a Kylin.2023! cluster nodes&#13;
b4519db09c96d8ad12efae818210e6521525e2bf 10.42.186.32:6379@16379 slave,fail? 4226cce5d7735c488a74e3aff86ad641d5c5e54b 1719909668604 1719909667601 1 connected&#13;
4226cce5d7735c488a74e3aff86ad641d5c5e54b 10.42.186.33:6379@16379 myself,master - 0 0 1 connected 0-16383&#13;
&#13;
```&#13;
4. 节点A(旧主节点)写入数据&#13;
```bash&#13;
redis-cli -h 10.42.186.32 -p 6379 -a Kylin.2023! set key32 data32&#13;
redis-cli -h 10.42.186.32 -p 6379 -a Kylin.2023! set AAA from32&#13;
redis-cli -h 10.42.186.32 -p 6379 -a Kylin.2023! set BBB from32&#13;
```&#13;
5. 节点B(新主节点)写入数据&#13;
```bash&#13;
redis-cli -h 10.42.186.33 -p 6379 -a Kylin.2023! set key33 data33&#13;
redis-cli -h 10.42.186.33 -p 6379 -a Kylin.2023! set AAA from33&#13;
redis-cli -h 10.42.186.33 -p 6379 -a Kylin.2023! set BBB from33&#13;
```&#13;
6. 恢复网络&#13;
```bash&#13;
# 10.42.186.32 执行下面命令&#13;
iptables -D INPUT -s 10.42.186.33 -j DROP&#13;
iptables -D OUTPUT -d 10.42.186.33 -j DROP&#13;
&#13;
# 10.42.186.33 执行下面命令&#13;
iptables -D INPUT -s 10.42.186.32 -j DROP&#13;
iptables -D OUTPUT -d 10.42.186.32 -j DROP&#13;
```&#13;
7. 查看数据，此时节点A(旧主节点)变成从节点，并且在网络隔离之后写的数据已经丢失，节点B(新主节点)变成主节点，redis集群的数据以新主节点中的数据为准&#13;
```bash&#13;
# 10.42.186.33 执行下面命令&#13;
redis-cli -h 10.42.186.33 -p 6379 -a Kylin.2023! get key32&#13;
返回值为 (nil)&#13;
redis-cli -h 10.42.186.33 -p 6379 -a Kylin.2023! get key33&#13;
返回值为 data33&#13;
redis-cli -h 10.42.186.33 -p 6379 -a Kylin.2023! get AAA&#13;
返回值为 from33&#13;
redis-cli -h 10.42.186.33 -p 6379 -a Kylin.2023! get BBB&#13;
返回值为 from33&#13;
# 10.42.186.32变成从节点，已经无法get key。</description><guid isPermaLink="true">https://longxiucai.github.io/post/redis-yi-zhu-yi-cong-ji-qun-nao-lie-xian-xiang-mo-ni.html</guid><pubDate>Tue, 02 Jul 2024 09:17:50 +0000</pubDate></item><item><title>shell中的特殊变量与数组</title><link>https://longxiucai.github.io/post/shell-zhong-de-te-shu-bian-liang-yu-shu-zu.html</link><description>`$0`	当前脚本的文件名。</description><guid isPermaLink="true">https://longxiucai.github.io/post/shell-zhong-de-te-shu-bian-liang-yu-shu-zu.html</guid><pubDate>Tue, 02 Jul 2024 06:43:32 +0000</pubDate></item><item><title>rpmdb报错</title><link>https://longxiucai.github.io/post/rpmdb-bao-cuo.html</link><description>执行yum、rpm命令失败:error: rpmdb: BDB0113 Thread/process 16978/139878363277376 failed: BDB1507 Thread died in Berkeley DB library&#13;
&#13;
可以通过以下命令解决&#13;
```&#13;
cd /var/lib/rpm&#13;
rm -rf __db*&#13;
rpm --rebuilddb&#13;
```。</description><guid isPermaLink="true">https://longxiucai.github.io/post/rpmdb-bao-cuo.html</guid><pubDate>Tue, 02 Jul 2024 06:29:10 +0000</pubDate></item><item><title>修改master3节点主机名</title><link>https://longxiucai.github.io/post/xiu-gai-master3-jie-dian-zhu-ji-ming.html</link><description>1. master1节点操作删除master3节点&#13;
```&#13;
kubectl delete node master3&#13;
```&#13;
2. master3节点操作&#13;
``` &#13;
kubeadm reset&#13;
rm -rf  /var/lib/etcd/&#13;
rm -rf /etc/kubernetes/manifests/*&#13;
hostnamectl set-hostname xxxxx&#13;
``` &#13;
&#13;
3. master1节点&#13;
```&#13;
kubectl exec -n kube-system -it etcd-master1 -- sh&#13;
alias etcdctl='etcdctl --endpoints=https://127.0.0.1:2379 --cacert=/etc/kubernetes/pki/etcd/ca.crt --cert=/etc/kubernetes/pki/etcd/server.crt --key=/etc/kubernetes/pki/etcd/server.key'&#13;
etcdctl member list&#13;
etcdctl member remove &lt;master3的id，上一步输出的第一列&gt;&#13;
exit&#13;
```&#13;
4. master1节点操作&#13;
```&#13;
kubeadm token create --print-join-command&#13;
kubeadm init phase upload-certs --upload-certs输出的最后一行字符串与上一步组合（--control-plane --certificate-key xxxxx）&#13;
```&#13;
组合完成后示例：&#13;
```&#13;
kubeadm join apiserver.cluster.local:6443 --token a6e1fm.b5lnpm64r7t707lw --discovery-token-ca-cert-hash sha256:06bc401679c6964d712790e0464d701030b27919c84807a30acb9c772e1a884f --control-plane --certificate-key b8e05ef60b5cecc78318cfe8148520ae2d46d0ac7871932cfeec7b36a0bd698e&#13;
```&#13;
5. master3执行上面组合之后的命令&#13;
。</description><guid isPermaLink="true">https://longxiucai.github.io/post/xiu-gai-master3-jie-dian-zhu-ji-ming.html</guid><pubDate>Tue, 02 Jul 2024 06:21:39 +0000</pubDate></item><item><title>linux安装启动过程</title><link>https://longxiucai.github.io/post/linux-an-zhuang-qi-dong-guo-cheng.html</link><description>1. isolinux.bin &amp; isolinux.cfg&#13;
&#13;
isolinux.bin是光盘引导程序，在mkisofs的选项中需要明确给出文件路径，这个文件属于SYSLINUX项目，对应fedora13中的syslinux包，文档可参考：/usr/share/doc/syslinux-4.02/isolinux.txt或者项目Wiki；可引导光盘相关信息请参考El Torito规范；&#13;
isolinux.cfg是isolinux.bin的配置文件，当光盘启动后（即运行isolinux.bin），会自动去找isolinux.cfg文件，然后根据配置信息进行后续工作；查找isolinux.cfg的顺序为:&#13;
boot/syslinux/isolinux.cfg&#13;
syslinux/isolinux.cfg&#13;
isolinux.cfg&#13;
&#13;
2. vesamenu.c32&#13;
&#13;
vesamenu.c32就是我们看到的光盘启动后的安装图形界面，也属于SYSLINUX项目，还有一个menu.c32版本，是纯文本的菜单；&#13;
&#13;
3. memtest&#13;
&#13;
如果通过光盘启动菜单选择了memtest选项，则开始进行内存检测；这是一个独立的程序，属于memtest86+项目，对应的fedora13的包是memtest86+-4.00-3.fc13.i686.rpm；通过效验md5值可以发现这个文件就是从包中提取出来的，发行版定制工具会从yum源将这个包安装到chroot中，然后将 /boot/memtest86+* 复制到ISO根目录；&#13;
&#13;
4. splash.jgp&#13;
&#13;
是光盘启动界面的背景图，应该来自文件 /usr/lib/anaconda-runtime/syslinux-vesa-splash.jpg，属于fedora-logos包；制作方法见Fedora官方Wiki：[How_to_create_a_custom_syslinux_splash](https://fedoraproject.org/wiki/How_to_create_a_custom_syslinux_splash)&#13;
&#13;
5. vmlinuz &amp; initrd.img&#13;
&#13;
vmlinuz是内核映像，initrd.img是ramfs (先cpio，再gzip压缩)，都是编译内核生成的；isolinux.bin根据安装选项找到对应的配置，装载内核和ramfs；&#13;
&#13;
6. install.img&#13;
&#13;
install.img是一个squashfs根文件系统，当内核启动后就装载install.img并切换根文件系统，执行里面的anaconda程序，anaconda是fedora的安装程序；&#13;
```&#13;
    $ sudo mount install.img /mnt -oloop   # mount&#13;
    $ sudo mksquashfs /dir                 # build&#13;
```&#13;
7. discinfo&#13;
&#13;
安装过程中，anaconda会去读取.discinfo文件，获取光盘信息（以前CD安装系统需要多张光盘），内容如下：&#13;
1273712438.740122     # timestamp （ python time.time() ）&#13;
Fedora 13             # releasestr&#13;
i386                  # arch&#13;
ALL                   # discNum （ALL表示只有一张安装盘）&#13;
注：参考文件/usr/lib/anaconda-runtime/makestamp.py &#13;
&#13;
8.Packages &amp; repodata&#13;
&#13;
packages就是存放包的目录，对这个目录执行createrepo命令就会生成一个repodata的目录，这个repodata就是yum源，里面的文件基本都是xml格式，记录了Packages中所有包的基本信息，如包名、包信息、包版本、包中的文件清单等等；&#13;
&#13;
。</description><guid isPermaLink="true">https://longxiucai.github.io/post/linux-an-zhuang-qi-dong-guo-cheng.html</guid><pubDate>Tue, 02 Jul 2024 06:18:07 +0000</pubDate></item><item><title>curl k8s api</title><link>https://longxiucai.github.io/post/curl%20k8s%20api.html</link><description>1. apply下面的资源文件&#13;
```&#13;
apiVersion: rbac.authorization.k8s.io/v1&#13;
kind: ClusterRoleBinding&#13;
metadata:&#13;
  name: test&#13;
roleRef:&#13;
  apiGroup: rbac.authorization.k8s.io&#13;
  kind: ClusterRole&#13;
  name: cluster-admin&#13;
subjects:&#13;
  - kind: ServiceAccount&#13;
    name: test&#13;
    namespace: kube-system&#13;
---&#13;
apiVersion: v1&#13;
kind: ServiceAccount&#13;
metadata:&#13;
  name: test&#13;
  namespace: kube-system&#13;
```&#13;
2. 执行下面命令(替换`KUBE_API`为实际)&#13;
```&#13;
JWT_TOKEN_KUBESYSTEM_DEFAULT=`kubectl get -n kube-system secret $(kubectl get serviceaccount -n kube-system test -o jsonpath='{.secrets[0].name}') -o jsonpath='{.data.token}' | base64 --decode`&#13;
KUBE_API=https://172.20.187.11:6443&#13;
```&#13;
3. 请求&#13;
```&#13;
curl  $KUBE_API/apis/apps/v1/deployments  --header 'Authorization: Bearer $JWT_TOKEN_KUBESYSTEM_DEFAULT' -k&#13;
```。</description><guid isPermaLink="true">https://longxiucai.github.io/post/curl%20k8s%20api.html</guid><pubDate>Tue, 02 Jul 2024 06:13:16 +0000</pubDate></item><item><title>linux家目录下的中文目录修改为英文</title><link>https://longxiucai.github.io/post/linux-jia-mu-lu-xia-de-zhong-wen-mu-lu-xiu-gai-wei-ying-wen.html</link><description>1. 将这些目录修改为英文名，如：  mv 桌面 Desktop &#13;
&#13;
2. 修改配置文件`~/.config/user-dirs.dirs`，将对应的路径改为英文名（要和1中修改的英文名对应）&#13;
&#13;
配置文件修改后的内容如下：&#13;
```&#13;
XDG_DESKTOP_DIR='$HOME/Desktop'&#13;
XDG_DOWNLOAD_DIR='$HOME/Download'&#13;
XDG_TEMPLATES_DIR='$HOME/Template'&#13;
XDG_PUBLICSHARE_DIR='$HOME/Public'&#13;
XDG_DOCUMENTS_DIR='$HOME/Document'&#13;
XDG_MUSIC_DIR='$HOME/Music'&#13;
XDG_PICTURES_DIR='$HOME/Picture'&#13;
XDG_VIDEOS_DIR='$HOME/Video'&#13;
```。</description><guid isPermaLink="true">https://longxiucai.github.io/post/linux-jia-mu-lu-xia-de-zhong-wen-mu-lu-xiu-gai-wei-ying-wen.html</guid><pubDate>Tue, 02 Jul 2024 06:09:53 +0000</pubDate></item><item><title>k8s dashbord的token创建，用于登录</title><link>https://longxiucai.github.io/post/k8s%20dashbord-de-token-chuang-jian-%EF%BC%8C-yong-yu-deng-lu.html</link><description>```&#13;
kubectl create serviceaccount cluster-admin-dashboard-sa&#13;
kubectl create clusterrolebinding cluster-admin-dashboard-sa --clusterrole=cluster-admin --serviceaccount=default:cluster-admin-dashboard-sa&#13;
kubectl describe secrets $(kubectl get secret | grep cluster-admin-dashboard-sa |cut -d ' ' -f1)|grep 'token:'&#13;
```。</description><guid isPermaLink="true">https://longxiucai.github.io/post/k8s%20dashbord-de-token-chuang-jian-%EF%BC%8C-yong-yu-deng-lu.html</guid><pubDate>Tue, 02 Jul 2024 06:06:03 +0000</pubDate></item><item><title>彩色echo</title><link>https://longxiucai.github.io/post/cai-se-echo.html</link><description>```&#13;
################# color code ####################&#13;
RED='31;1m'      # Error message&#13;
GREEN='32;1m'    # Success message&#13;
YELLOW='33;1m'   # Warning message&#13;
BLUE='36;1m'     # Info message&#13;
LIGHT_BLUE='36m' # Debug message&#13;
################# color echo ####################&#13;
colorEcho() { echo -e '\033[${1}${@:2}\033[0m'; }&#13;
error() { colorEcho $RED $1; }&#13;
success() { colorEcho $GREEN $1; }&#13;
warn() { colorEcho $YELLOW $1; }&#13;
info() { colorEcho $BLUE $1; }&#13;
################ end of color echo ##############&#13;
```。</description><guid isPermaLink="true">https://longxiucai.github.io/post/cai-se-echo.html</guid><pubDate>Tue, 02 Jul 2024 06:04:42 +0000</pubDate></item><item><title>c程序占用文件描述符</title><link>https://longxiucai.github.io/post/c-cheng-xu-zhan-yong-wen-jian-miao-shu-fu.html</link><description>## c程序打开多个文件&#13;
```&#13;
#include &lt;stdio.h&gt;&#13;
#include &lt;stdlib.h&gt;&#13;
#include &lt;fcntl.h&gt;&#13;
#include &lt;unistd.h&gt;&#13;
#include &lt;signal.h&gt;&#13;
&#13;
int *fds = NULL;&#13;
int number_of_files = 0;&#13;
int last_files = 0;&#13;
void cleanup() {&#13;
    if (fds != NULL) {&#13;
        for (int i = 0; i &lt; last_files + 1; i++) {&#13;
            if (fds[i] != -1) {&#13;
                close(fds[i]);&#13;
                printf('Closed file descriptor %d\n', fds[i]);&#13;
            }&#13;
&#13;
            char filename[256];&#13;
            snprintf(filename, sizeof(filename), '/tmp/testfile_%d.txt', i);&#13;
            if (unlink(filename) == 0) {&#13;
                printf('Deleted file %s\n', filename);&#13;
            } else {&#13;
                perror('unlink');&#13;
            }&#13;
        }&#13;
        free(fds);&#13;
        fds = NULL;&#13;
        printf('Freed allocated memory\n');&#13;
    }&#13;
}&#13;
&#13;
void signal_handler(int signal) {&#13;
    if (signal == SIGINT) {&#13;
        printf('\nCaught SIGINT signal, performing cleanup...\n');&#13;
        cleanup();&#13;
        exit(EXIT_FAILURE);&#13;
    }&#13;
}&#13;
&#13;
void open_many_files(int num_files) {&#13;
    number_of_files = num_files;&#13;
    fds = malloc(number_of_files * sizeof(int));&#13;
    if (fds == NULL) {&#13;
        perror('malloc');&#13;
        exit(EXIT_FAILURE);&#13;
    }&#13;
&#13;
    for (int i = 0; i &lt; number_of_files; i++) {&#13;
        char filename[256];&#13;
        snprintf(filename, sizeof(filename), '/tmp/testfile_%d.txt', i);&#13;
        fds[i] = open(filename, O_RDWR | O_CREAT, 0644);&#13;
        if (fds[i] == -1) {&#13;
            perror('open');&#13;
            break;&#13;
        }&#13;
        printf('Opened file descriptor %d for %s\n', fds[i], filename);&#13;
        last_files = i;&#13;
    }&#13;
}&#13;
&#13;
int main(int argc, char *argv[]) {&#13;
    if (argc != 3) {&#13;
        fprintf(stderr, 'Usage: %s &lt;number_of_files_to_open&gt; &lt;wait_time_in_seconds&gt;\n', argv[0]);&#13;
        exit(EXIT_FAILURE);&#13;
    }&#13;
&#13;
    // Register the signal handler for SIGINT&#13;
    signal(SIGINT, signal_handler);&#13;
&#13;
    int num_files_to_open = atoi(argv[1]);&#13;
    int wait_time = atoi(argv[2]);&#13;
&#13;
    open_many_files(num_files_to_open);&#13;
&#13;
    // Wait for the specified time before closing file descriptors&#13;
    printf('Waiting for %d seconds before closing file descriptors...\n', wait_time);&#13;
    sleep(wait_time);&#13;
&#13;
    cleanup();&#13;
&#13;
    return 0;&#13;
}&#13;
```&#13;
## 在pod中复现`too many open files in system`的情况&#13;
*  修改limit.conf中nofile，现在文件打开数量，在pod中不会报错，直接在宿主机中运行程序会报错&#13;
*  修改内核参数fs.file-max，降低值内核参数的值，pod中会报错。</description><guid isPermaLink="true">https://longxiucai.github.io/post/c-cheng-xu-zhan-yong-wen-jian-miao-shu-fu.html</guid><pubDate>Tue, 02 Jul 2024 06:03:36 +0000</pubDate></item><item><title>cgroup&amp;多线程测试</title><link>https://longxiucai.github.io/post/cgroup%26-duo-xian-cheng-ce-shi.html</link><description>## C代码：thread.c&#13;
```&#13;
#include&lt;stdio.h&gt;&#13;
#include&lt;stdlib.h&gt;&#13;
#include&lt;pthread.h&gt;&#13;
#include &lt;unistd.h&gt; &#13;
/* 声明结构体 */&#13;
struct member&#13;
{&#13;
    int num;&#13;
    char *name;&#13;
};     &#13;
&#13;
/* 定义线程pthread */&#13;
static void * pthread(void *arg)       &#13;
{&#13;
    struct member *temp;&#13;
    &#13;
    /* 线程pthread开始运行 */&#13;
    printf('pthread start!\n');&#13;
    while(1){&#13;
    ;&#13;
    }&#13;
    /* 令主线程继续执行 */&#13;
    sleep(2);&#13;
    &#13;
    /* 打印传入参数 */&#13;
    temp = (struct member *)arg;      &#13;
    printf('member-&gt;num:%d\n',temp-&gt;num);&#13;
    printf('member-&gt;name:%s\n',temp-&gt;name);&#13;
    &#13;
    return NULL;&#13;
}&#13;
&#13;
/* main函数 */&#13;
int main(int agrc,char* argv[])&#13;
{&#13;
    pthread_t tidp,tidp1;&#13;
    struct member *b;&#13;
&#13;
    /* 为结构体变量b赋值 */&#13;
    b = (struct member *)malloc(sizeof(struct member));           &#13;
    b-&gt;num=1;&#13;
    b-&gt;name='mlq';              &#13;
&#13;
    /* 创建线程pthread */&#13;
    if ((pthread_create(&amp;tidp, NULL, pthread, (void*)b)) == -1)&#13;
    {&#13;
        printf('create error!\n');&#13;
        return 1;&#13;
    }&#13;
    if ((pthread_create(&amp;tidp1, NULL, pthread, (void*)b)) == -1)&#13;
    {&#13;
        printf('create error!\n');&#13;
        return 1;&#13;
    }&#13;
&#13;
    /* 令线程pthread先运行 */&#13;
    sleep(1);&#13;
    &#13;
    /* 线程pthread睡眠2s，此时main可以先执行 */&#13;
    printf('main continue!\n');&#13;
    &#13;
    /* 等待线程pthread释放 */&#13;
    if (pthread_join(tidp, NULL))                  &#13;
    {&#13;
        printf('thread is not exit...\n');&#13;
        return -2;&#13;
    }&#13;
    &#13;
    return 0;&#13;
}&#13;
```&#13;
## 编译&#13;
```&#13;
gcc -o thread.out thread.c -lpthread&#13;
```&#13;
## 测试&#13;
1、`systemd-run --unit=threadtest --slice=test  /root/thread.out` 会启动一个临时服务,该服务就是运行/root/thread.out，名为threadtest.service&#13;
2、查看`top -H -p &lt;threadtest.service的pid&gt;`会显示该服务及其线程的信息&#13;
3、cgroup：/sys/fs/cgroup/cpu/test.slice/threadtest.service。</description><guid isPermaLink="true">https://longxiucai.github.io/post/cgroup%26-duo-xian-cheng-ce-shi.html</guid><pubDate>Tue, 02 Jul 2024 05:56:42 +0000</pubDate></item><item><title>bucketbench测试crio步骤</title><link>https://longxiucai.github.io/post/bucketbench-ce-shi-crio-bu-zou.html</link><description>1. 安装crio&#13;
&#13;
2. 修改crio配置文件的[crio.image]字段，添加一行pause_image      字段位于第444行&#13;
vim /etc/crio/crio.conf&#13;
[crio.image]&#13;
pause_image = 'harbor.kylincloudnative.com/registry.k8s.io/pause:3.6'&#13;
&#13;
3. 配置cgroup&#13;
mkdir -p /etc/crio/crio.conf.d&#13;
cat &gt;/etc/crio/crio.conf.d/02-cgroup-manager.conf&lt;&lt;-EOF&#13;
[crio.runtime]&#13;
conmon_cgroup = 'pod'&#13;
cgroup_manager = 'cgroupfs'&#13;
EOF&#13;
&#13;
&#13;
4. 重启并观察状态是否running&#13;
systemctl daemon-reload&#13;
systemctl restart crio&#13;
systemctl status crio&#13;
&#13;
5. 拉镜像，修改tag&#13;
```&#13;
podman pull harbor.kylincloudnative.com/library/alpine:latest&#13;
podman pull harbor.kylincloudnative.com/registry.k8s.io/pause:3.6&#13;
podman pull harbor.kylincloudnative.com/registry.k8s.io/pause:3.1&#13;
podman tag harbor.kylincloudnative.com/registry.k8s.io/pause:3.6 registry.aliyuncs.com/google_containes/pause:3.6&#13;
podman tag harbor.kylincloudnative.com/registry.k8s.io/pause:3.1 registry.aliyuncs.com/google_containers/pause:3.1&#13;
```&#13;
6. 修改测试工具配置文件&#13;
* 修改 contrib/container_config.json      位于第7行&#13;
image.image修改为harbor.kylincloudnative.com/library/alpine:latest&#13;
* 修改 examples/crio.yaml   位于第2行&#13;
image: harbor.kylincloudnative.com/library/alpine:latest&#13;
* 修改 examples/crio.yaml中的线程数相关配置：&#13;
   threads: xxxxxxxx&#13;
   iterations: xxxxxxxx.&#13;
&#13;
7. 测试 arm&#13;
./bucketbench-aarch64 --log-level=debug run -b   examples/crio.yaml --skip-limit&#13;
&#13;
&#13;
&gt; [!TIP]&#13;
&gt; 如报错`xxxxxx : name is reserved`，则需删除pod：&#13;
```&#13;
for i in $(crictl pods | awk -F ' ' '{print$1}' | xargs) ;do crictl stopp $i; done&#13;
for i in $(crictl pods | awk -F ' ' '{print$1}' | xargs) ;do crictl rmp $i; done&#13;
```&#13;
。</description><guid isPermaLink="true">https://longxiucai.github.io/post/bucketbench-ce-shi-crio-bu-zou.html</guid><pubDate>Tue, 02 Jul 2024 05:51:53 +0000</pubDate></item><item><title>bond配置</title><link>https://longxiucai.github.io/post/bond-pei-zhi.html</link><description>1. 配置ifcfg-xxx1接口 路径为 /etc/sysconfig/network-scripts/&#13;
TYPE=Ethernet&#13;
NAME=xxx1&#13;
BOOTPROTO=none&#13;
DEVICE=xxx1&#13;
ONBOOT=yes&#13;
MASTER=bond0&#13;
SLAVE=yes&#13;
2. 同1，配置ifcfg-xxx2接口&#13;
3. 新建ifcfg-bond0文件，内容如下&#13;
TYPE=Ethernet&#13;
NAME=bond0&#13;
BOOTPROTO=static&#13;
DEVICE=bond0&#13;
ONBOOT=yes&#13;
IPADDR=xxxx&#13;
NATMASK=XXXX&#13;
GATEWAY=172.20.43.253&#13;
DNS1=172.20.191.2&#13;
DNS2=114.114.114.114&#13;
BONDING_OPTS='mode=6 miimon=100'&#13;
4. 加载模块，让系统支持bonding    ？？？？？？&#13;
cat/etc/modprobe.conf？？？/etc/modprobe.d/bonding.conf？？？  //不存在的话，手动创建（也可以放在modprobe.d下面）&#13;
alias bond0 bonding&#13;
options bond0 miimon=100 mode=0&#13;
5. 加载bond module：modprobe bonding&#13;
6. systemctl restart network&#13;
7. 查看绑定结果&#13;
`cat  /proc/net/bonding/bond0`&#13;
&#13;
参考：&#13;
https://www.cnblogs.com/huangweimin/articles/6527058.html&#13;
https://blog.csdn.net/qq_34870631/article/details/80625217&#13;
。</description><guid isPermaLink="true">https://longxiucai.github.io/post/bond-pei-zhi.html</guid><pubDate>Tue, 02 Jul 2024 05:45:43 +0000</pubDate></item><item><title>网桥配置脚本</title><link>https://longxiucai.github.io/post/wang-qiao-pei-zhi-jiao-ben.html</link><description>#!/bin/bash&#13;
ifname=ens3&#13;
brname=bridge0&#13;
ip=172.20.43.11/24&#13;
gateway=172.20.43.253&#13;
dns='172.20.191.2,114.114.114.114'&#13;
nmcli connection add ifname $brname type bridge con-name $brname&#13;
nmcli connection delete ${ifname}&#13;
nmcli connection add type bridge-slave ifname ${ifname} master $brname&#13;
nmcli connection modify $brname ipv4.addresses $ip&#13;
nmcli connection modify $brname ipv4.gateway $gateway&#13;
nmcli connection modify $brname ipv4.dns $dns&#13;
nmcli connection modify $brname ipv4.method manual&#13;
nmcli connection up $brname。</description><guid isPermaLink="true">https://longxiucai.github.io/post/wang-qiao-pei-zhi-jiao-ben.html</guid><pubDate>Tue, 02 Jul 2024 05:43:51 +0000</pubDate></item><item><title>临时修改initrd.img</title><link>https://longxiucai.github.io/post/lin-shi-xiu-gai-initrd.img.html</link><description>## 解压&#13;
mkdir tmpdir&#13;
cd tmpdir&#13;
xzcat -d ../initrd.img | cpio -idum   #解压img输出到当前所在目录&#13;
&#13;
## 修改&#13;
....&#13;
&#13;
## 重新打包&#13;
find . | cpio -oH newc | xz --check=crc32 -9 &gt; ../initrd.img&#13;
&#13;
cpio -H参数说明：&#13;
* bin 过时的二进制格式。</description><guid isPermaLink="true">https://longxiucai.github.io/post/lin-shi-xiu-gai-initrd.img.html</guid><pubDate>Tue, 02 Jul 2024 05:40:28 +0000</pubDate></item><item><title>正则表达式</title><link>https://longxiucai.github.io/post/zheng-ze-biao-da-shi.html</link><description>## 元字符说明&#13;
&#13;
    元字符:  |&#13;
    匹配规则:匹配|两边任意一个正则表达式&#13;
&#13;
    元字符:  .&#13;
    匹配规则:匹配除换行外的任意字符&#13;
&#13;
    元字符:  ^&#13;
    匹配规则:匹配目标字符串的开头位置&#13;
&#13;
    元字符:  $&#13;
    匹配规则:匹配字符串的结束位置&#13;
&#13;
    元字符:  *&#13;
    匹配规则:匹配前面的字符出现0次或多次&#13;
&#13;
    元字符:  +&#13;
    匹配规则:匹配前面的字符出现一次或多次&#13;
&#13;
	元字符:  ?&#13;
	匹配规则:匹配前面的字符出现0次或1次&#13;
&#13;
    元字符:  {n}&#13;
    匹配规则:匹配指定的重复次数&#13;
   &#13;
	 元字符: {m,n}   &#13;
    匹配规则:匹配前面的正则表达式 m--n次        &#13;
&#13;
&#13;
## 匹配字符集合&#13;
&#13;
* 元字符:`[字符集]`&#13;
&#13;
    匹配规则:匹配任意一个字符集下的字符&#13;
```&#13;
    [abc123] a b c 1 2 3 12 &#13;
	[a-z] [0-9] [_123a-z]&#13;
    eg:&#13;
    &gt;&gt;&gt; re.findall('^[a-z][a-z]','boy')&#13;
    ['bo']&#13;
```&#13;
* 元字符:`[^...]`&#13;
&#13;
    匹配规则:字符集取非,除了列出的字符之外任意一个字符&#13;
```&#13;
    [^abc]--&gt;除abc之外任意字符&#13;
    eg:&#13;
    &gt;&gt;&gt; re.findall('[^abcds]','boyadshfhjasjhbhjasf')&#13;
    ['o', 'y', 'h', 'f', 'h', 'j', 'j', 'h', 'h', 'j', 'f']&#13;
```&#13;
&#13;
* 元字符: `\d`  `\D`&#13;
&#13;
    匹配规则: &#13;
&#13;
    `\d` 匹配任意数字字符      [0-9]&#13;
    &#13;
    `\D` 匹配任意非数字字符    [^0-9]&#13;
```&#13;
    eg:&#13;
    &gt;&gt;&gt; re.findall('\D','AID1807')&#13;
    ['A', 'I', 'D']&#13;
&#13;
	\1,\2	反向引用	匹配之前第一、第二括号内表达式匹配的内容&#13;
&#13;
	举个例子，想找到连续两个重复单词，我们就必须要知道前面单词是什么，这时候就可以使用反向引用了，可以简单写为(\w+)\s+\1&#13;
```&#13;
	&#13;
* 元字符:`\w`  `\W`&#13;
    匹配规则:&#13;
&#13;
    `\w` 普通字符  &#13;
    &#13;
    `\W` 非普通字符&#13;
```&#13;
    eg:&#13;
    &gt;&gt;&gt; re.findall('\w','我在北京')&#13;
    ['我', '在', '北', '京']&#13;
            &#13;
    &gt;&gt;&gt; re.findall('\W','!@#$我在北京')&#13;
    ['!', '@', '#', '$']&#13;
```&#13;
&#13;
* 元字符: `\s` `\S`&#13;
    匹配规则:&#13;
&#13;
    `\s` 匹配任意空字符`[\r\t\n\v\f]`&#13;
&#13;
    `\S` 匹配任意非空字符&#13;
```&#13;
    eg:&#13;
    &gt;&gt;&gt; re.findall('\w+\s+\w+','hello     beijin')&#13;
    ['hello     beijin']&#13;
    &gt;&gt;&gt; re.findall('\w+\S+\w+','hello     beijin')&#13;
    ['hello', 'beijin']&#13;
```&#13;
* 元字符: `\A` `\Z`&#13;
   &#13;
    匹配规则:&#13;
    &#13;
    `\A` 匹配字符串开头位置  `^`&#13;
&#13;
    `\Z` 匹配字符串结尾位置  `$`&#13;
```&#13;
    &gt;&gt;&gt; re.findall('\Ahello','hellobeijin')&#13;
    ['hello']&#13;
    &gt;&gt;&gt; re.findall('beijin\Z','hellobeijin')&#13;
    ['beijin']&#13;
```&#13;
绝对匹配:正则表达式完全匹配目标字符串内容&#13;
&#13;
在正则表达式的开头或者结尾加上`^`或者`$`(或者`\A` `\Z`).这样正则表达式必须匹配到整个目标字符串才会有结果&#13;
```&#13;
    eg:&#13;
    &gt;&gt;&gt; re.findall('\A\d+$','1234568789')&#13;
    ['1234568789']&#13;
&#13;
    匹配(非)单词边界&#13;
    \&lt;	单词分界符	匹配单词开始	java中使用\b&#13;
	\&gt;	单词分界符	匹配单词结束	java中使用\B&#13;
```&#13;
* 元字符: `\b` `\B`&#13;
    &#13;
    匹配规则:&#13;
    &#13;
    `\b` 匹配单词边界位置&#13;
&#13;
    `\B` 匹配非单词边界位置&#13;
            普通字符和非普通字符认为是单词边界&#13;
```&#13;
    eg:&#13;
    &gt;&gt;&gt; re.findall(r'he\b','he ##is a good gril')&#13;
    ['he']&#13;
```&#13;
 &#13;
## 元字符总结&#13;
&#13;
匹配单个字符: &#13;
```&#13;
a  .  \d   \D  \s  \S  \w   \W  [...]  [^...]&#13;
```&#13;
匹配重复: &#13;
```&#13;
*  +  ?  {n}  {m,n}&#13;
```&#13;
匹配位置:&#13;
```&#13;
^  $  \A  \Z  \b  \B&#13;
```&#13;
其他: &#13;
```&#13;
|  ()  \&#13;
```&#13;
## 正则表达式转义&#13;
&#13;
正则中的特殊字符&#13;
```&#13;
. * + ? ^ $ [] {} () | \&#13;
```&#13;
正则表达式如果匹配特殊字符需要加`\`表达转义&#13;
```&#13;
    eg:             正则  目标字符串&#13;
    &gt;&gt;&gt; re.findall('\$\d+','$10')&#13;
    ['$10']&#13;
&#13;
             pattern     string&#13;
    python  '\\$\\d+'     '$10'&#13;
    python   r'\$\d+'     '$10'&#13;
&#13;
    raw子串: 原始字符串对内容不解释转义,就表达内容原本的意义&#13;
```&#13;
## 贪婪和非贪婪&#13;
&#13;
贪婪模式:正则表达式的重复匹配总是尽可能多的向后匹配更多内容`* + ? {m,n}`&#13;
&#13;
非贪婪模式(懒惰模式):尽可能少的匹配内容&#13;
```&#13;
    贪婪---&gt;非贪婪 *?  +?  ??   {m,n}?&#13;
    &gt;&gt;&gt; re.findall(r'ab','abbbbbbbbbbb')&#13;
    ['ab']&#13;
    &#13;
    &gt;&gt;&gt; re.findall(r'ab+','abbbbbbbbbbb')&#13;
    ['abbbbbbbbbbb']&#13;
    &#13;
    &gt;&gt;&gt; re.findall(r'ab{3,5}?','abbbbbbbbbbb')&#13;
    ['abbb']&#13;
```&#13;
## 正则表达式的子组&#13;
可以使用()为正则表达式建立子组,子组可以看做是正则表达式内部操作的一个整体&#13;
&#13;
子组是在正则表达式整体匹配到内容的前提下才会发挥的作用,他不影响正则表达式整体去匹配目标内容这一原则&#13;
&#13;
子组作用&#13;
&#13;
1.作为内部整体可以改变某些原字符的行为&#13;
    eg:&#13;
    &gt;&gt;&gt; re.search(r'(ab)+\d+','abababab123456').group()&#13;
    'abababab123456'&#13;
&#13;
2.子组在某些操作中可以单独提取出匹配内容&#13;
    &gt;&gt;&gt; re.search(r'(https|http|ftp)://\S+','https://baidu.com').group()&#13;
    'https://baidu.com'&#13;
&#13;
&#13;
子组使用注意事项:&#13;
* 一个正则表达式中可以有多个子组&#13;
* 子组一般由外到内,左到右称之为第一,第二,第三...子组&#13;
* 子组不能重叠,嵌套也不宜很复杂&#13;
&#13;
&#13;
## 捕获组和非捕获组&#13;
&#13;
格式:&#13;
```&#13;
(?P&lt;name&gt;pattern)&#13;
&#13;
&gt;&gt;&gt; re.search(r'(?P&lt;dog&gt;ab)cdef','abcdefghijklmn').group('dog')&#13;
'ab'&#13;
```&#13;
作用:可以通过组名更方便获取某组内容。</description><guid isPermaLink="true">https://longxiucai.github.io/post/zheng-ze-biao-da-shi.html</guid><pubDate>Tue, 02 Jul 2024 05:36:57 +0000</pubDate></item><item><title>修改pod网段与calico配置</title><link>https://longxiucai.github.io/post/xiu-gai-pod-wang-duan-yu-calico-pei-zhi.html</link><description>1. vim /etc/kubernetes/manifests/kube-controller-manager.yaml 【3个master一个一个的执行，最好是kube-controller-manager-节点名字的pod Running之后再修改下一个节点】&#13;
		19行：--cluster-cidr=10.128.0.0/18&#13;
&#13;
2. kubectl edit cm kubeadm-config -n kube-system&#13;
		podSubnet: 10.128.0.0/18&#13;
&#13;
3. kubectl edit cm kube-proxy -n kube-system&#13;
		clusterCIDR: 10.128.0.0/18&#13;
&#13;
4. kubectl edit ippool default-ipv4-ippool&#13;
		cidr: 10.128.0.0/18&#13;
&#13;
5. kubectl edit cm calico-config -n kube-system ：&#13;
          'ipam': {&#13;
              'type': 'calico-ipam',					              #逗号&#13;
              'ipv4_pools': ['default-ipv4-ippool']   #添加此行，前面必须是空格不能是tab&#13;
          },&#13;
&#13;
6. kubectl rollout restart -n kube-system daemonset.apps/calico-node&#13;
等待calico的pod全部running，全部节点查看配置文件是否有'ipv4_pools': ['default-ipv4-ippool']：&#13;
cat /etc/cni/net.d/00-multus.conf&#13;
cat /etc/cni/net.d/10-calico.conflist&#13;
&#13;
7. kubectl  edit ippool kubevirt-vm-ippool&#13;
  cidr: 10.128.128.0/18&#13;
&#13;
8. kubectl delete ippool other-ippool&#13;
&#13;
9. kubectl cluster-info dump | grep cluster-cidr&#13;
&#13;
&#13;
默认使用default pool，开启noipam功能&#13;
calico-config configMap:&#13;
cni.projectcalico.org/ipAddrsNoIpam&#13;
```&#13;
apiVersion: v1&#13;
data:&#13;
  calico_backend: bird&#13;
  cni_network_config: |-&#13;
    {&#13;
      'name': 'k8s-pod-network',&#13;
      'cniVersion': '0.3.1',&#13;
      'plugins': [&#13;
        {&#13;
          'type': 'calico',&#13;
          'log_level': 'info',&#13;
          'log_file_path': '/var/log/calico/cni/cni.log',&#13;
          'datastore_type': 'kubernetes',&#13;
          'nodename': '__KUBERNETES_NODE_NAME__',&#13;
          'mtu': __CNI_MTU__,&#13;
          'ipam': {&#13;
              'type': 'calico-ipam',&#13;
              'ipv4_pools': ['default-ipv4-ippool']&#13;
          },&#13;
          'policy': {&#13;
              'type': 'k8s'&#13;
          },&#13;
          'kubernetes': {&#13;
              'kubeconfig': '__KUBECONFIG_FILEPATH__'&#13;
          },&#13;
         'feature_control': {&#13;
             'ip_addrs_no_ipam': true&#13;
         }&#13;
        },&#13;
        {&#13;
          'type': 'portmap',&#13;
          'snat': true,&#13;
          'capabilities': {'portMappings': true}&#13;
        },&#13;
        {&#13;
          'type': 'bandwidth',&#13;
          'capabilities': {'bandwidth': true}&#13;
        }&#13;
      ]&#13;
    }&#13;
  typha_service_name: none&#13;
  veth_mtu: '0'&#13;
kind: ConfigMap&#13;
metadata:&#13;
  name: calico-config&#13;
  namespace: kube-system&#13;
```&#13;
&#13;
。</description><guid isPermaLink="true">https://longxiucai.github.io/post/xiu-gai-pod-wang-duan-yu-calico-pei-zhi.html</guid><pubDate>Tue, 02 Jul 2024 03:23:13 +0000</pubDate></item><item><title>go解析证书文件</title><link>https://longxiucai.github.io/post/go-jie-xi-zheng-shu-wen-jian.html</link><description>```&#13;
package cert&#13;
&#13;
import (&#13;
	'crypto/x509'&#13;
	'encoding/pem'&#13;
	'os'&#13;
	'path/filepath'&#13;
	'strings'&#13;
	'time'&#13;
&#13;
	log 'github.com/sirupsen/logrus'&#13;
)&#13;
&#13;
func parseCertificate(file string) {&#13;
	// 读取文件内容&#13;
	fileData, err := os.ReadFile(file)&#13;
	if err != nil {&#13;
		log.Errorf('Error reading file %s: %s\n', file, err)&#13;
		return&#13;
	}&#13;
&#13;
	// 解析 PEM 块&#13;
	block, _ := pem.Decode(fileData)&#13;
	if block == nil {&#13;
		log.Errorf('No PEM block found in file %s\n', file)&#13;
		return&#13;
	}&#13;
&#13;
	// 判断文件类型&#13;
	fileType := strings.ToLower(filepath.Ext(file))&#13;
	switch fileType {&#13;
	case '.crt', '.pem':&#13;
		// 解析证书&#13;
		cert, err := x509.ParseCertificate(block.Bytes)&#13;
		if err != nil {&#13;
			log.Errorf('Error parsing certificate from file %s: %s\n', file, err)&#13;
			return&#13;
		}&#13;
&#13;
		// 输出证书有效期等信息&#13;
		log.Infof('Certificate in file %s:', file)&#13;
		log.Infof('  Subject: %s', cert.Subject.CommonName)&#13;
		log.Infof('  Valid from: %s', cert.NotBefore)&#13;
		log.Infof('  Valid until: %s', cert.NotAfter)&#13;
&#13;
		// 计算证书有效期结束时间与当前时间之间的天数差&#13;
		now := time.Now()&#13;
		expiresInDays := int((time.Duration(cert.NotAfter.Sub(now).Hours()) / 24))&#13;
		log.Infof('证书%s 将于 %d 天后过期', cert.Subject.CommonName, expiresInDays)&#13;
		log.Infof('---------------------------')&#13;
	default:&#13;
		log.Infof('Unsupported file type: %s %s', fileType, file)&#13;
	}&#13;
}&#13;
```。</description><guid isPermaLink="true">https://longxiucai.github.io/post/go-jie-xi-zheng-shu-wen-jian.html</guid><pubDate>Tue, 02 Jul 2024 02:33:15 +0000</pubDate></item><item><title>go连接数据库</title><link>https://longxiucai.github.io/post/go-lian-jie-shu-ju-ku.html</link><description>```&#13;
package dbtest&#13;
&#13;
import (&#13;
	'database/sql'&#13;
	'fmt'&#13;
	'log'&#13;
&#13;
	_ 'github.com/go-sql-driver/mysql'&#13;
)&#13;
&#13;
func maindb() {&#13;
	// 连接 MySQL 数据库&#13;
	db, err := sql.Open('mysql', 'dbinit:123456@tcp(10.42.186.232:3306)/dbinit_test')&#13;
	if err != nil {&#13;
		log.Fatal(err)&#13;
	}&#13;
	defer db.Close()&#13;
&#13;
	// 测试连接&#13;
	err = db.Ping()&#13;
	if err != nil {&#13;
		log.Fatal('Error connecting to the database:', err)&#13;
	}&#13;
&#13;
	fmt.Println('Connected to MySQL database successfully!')&#13;
&#13;
	// 查询示例&#13;
	rows, err := db.Query('SELECT * FROM users')&#13;
	if err != nil {&#13;
		log.Fatal('Error executing query:', err)&#13;
	}&#13;
	defer rows.Close()&#13;
&#13;
	// 遍历查询结果&#13;
	for rows.Next() {&#13;
		var id int&#13;
		var name string&#13;
		err := rows.Scan(&amp;id, &amp;name)&#13;
		if err != nil {&#13;
			log.Fatal('Error scanning row:', err)&#13;
		}&#13;
		fmt.Printf('ID: %d, Name: %s\n', id, name)&#13;
	}&#13;
}&#13;
```。</description><guid isPermaLink="true">https://longxiucai.github.io/post/go-lian-jie-shu-ju-ku.html</guid><pubDate>Tue, 02 Jul 2024 02:04:36 +0000</pubDate></item></channel></rss>
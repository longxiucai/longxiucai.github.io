## 元字符说明

    元字符:  |
    匹配规则:匹配|两边任意一个正则表达式

    元字符:  .
    匹配规则:匹配除换行外的任意字符

    元字符:  ^
    匹配规则:匹配目标字符串的开头位置

    元字符:  $
    匹配规则:匹配字符串的结束位置

    元字符:  *
    匹配规则:匹配前面的字符出现0次或多次

    元字符:  +
    匹配规则:匹配前面的字符出现一次或多次

	元字符:  ?
	匹配规则:匹配前面的字符出现0次或1次

    元字符:  {n}
    匹配规则:匹配指定的重复次数
   
	 元字符: {m,n}   
    匹配规则:匹配前面的正则表达式 m--n次        


## 匹配字符集合

* 元字符:`[字符集]`

    匹配规则:匹配任意一个字符集下的字符
```
    [abc123] a b c 1 2 3 12 
	[a-z] [0-9] [_123a-z]
    eg:
    >>> re.findall('^[a-z][a-z]','boy')
    ['bo']
```
* 元字符:`[^...]`

    匹配规则:字符集取非,除了列出的字符之外任意一个字符
```
    [^abc]-->除abc之外任意字符
    eg:
    >>> re.findall('[^abcds]','boyadshfhjasjhbhjasf')
    ['o', 'y', 'h', 'f', 'h', 'j', 'j', 'h', 'h', 'j', 'f']
```

* 元字符: `\d`  `\D`

    匹配规则: 

    `\d` 匹配任意数字字符      [0-9]
    
    `\D` 匹配任意非数字字符    [^0-9]
```
    eg:
    >>> re.findall('\D','AID1807')
    ['A', 'I', 'D']

	\1,\2	反向引用	匹配之前第一、第二括号内表达式匹配的内容

	举个例子，想找到连续两个重复单词，我们就必须要知道前面单词是什么，这时候就可以使用反向引用了，可以简单写为(\w+)\s+\1
```
	
* 元字符:`\w`  `\W`
    匹配规则:

    `\w` 普通字符  
    
    `\W` 非普通字符
```
    eg:
    >>> re.findall('\w','我在北京')
    ['我', '在', '北', '京']
            
    >>> re.findall('\W','!@#$我在北京')
    ['!', '@', '#', '$']
```

* 元字符: `\s` `\S`
    匹配规则:

    `\s` 匹配任意空字符`[\r\t\n\v\f]`

    `\S` 匹配任意非空字符
```
    eg:
    >>> re.findall('\w+\s+\w+','hello     beijin')
    ['hello     beijin']
    >>> re.findall('\w+\S+\w+','hello     beijin')
    ['hello', 'beijin']
```
* 元字符: `\A` `\Z`
   
    匹配规则:
    
    `\A` 匹配字符串开头位置  `^`

    `\Z` 匹配字符串结尾位置  `$`
```
    >>> re.findall('\Ahello','hellobeijin')
    ['hello']
    >>> re.findall('beijin\Z','hellobeijin')
    ['beijin']
```
绝对匹配:正则表达式完全匹配目标字符串内容

在正则表达式的开头或者结尾加上`^`或者`$`(或者`\A` `\Z`).这样正则表达式必须匹配到整个目标字符串才会有结果
```
    eg:
    >>> re.findall('\A\d+$','1234568789')
    ['1234568789']

    匹配(非)单词边界
    \<	单词分界符	匹配单词开始	java中使用\b
	\>	单词分界符	匹配单词结束	java中使用\B
```
* 元字符: `\b` `\B`
    
    匹配规则:
    
    `\b` 匹配单词边界位置

    `\B` 匹配非单词边界位置
            普通字符和非普通字符认为是单词边界
```
    eg:
    >>> re.findall(r'he\b','he ##is a good gril')
    ['he']
```
 
## 元字符总结

匹配单个字符: 
```
a  .  \d   \D  \s  \S  \w   \W  [...]  [^...]
```
匹配重复: 
```
*  +  ?  {n}  {m,n}
```
匹配位置:
```
^  $  \A  \Z  \b  \B
```
其他: 
```
|  ()  \
```
## 正则表达式转义

正则中的特殊字符
```
. * + ? ^ $ [] {} () | \
```
正则表达式如果匹配特殊字符需要加`\`表达转义
```
    eg:             正则  目标字符串
    >>> re.findall('\$\d+','$10')
    ['$10']

             pattern     string
    python  '\\$\\d+'     '$10'
    python   r'\$\d+'     '$10'

    raw子串: 原始字符串对内容不解释转义,就表达内容原本的意义
```
## 贪婪和非贪婪

贪婪模式:正则表达式的重复匹配总是尽可能多的向后匹配更多内容`* + ? {m,n}`

非贪婪模式(懒惰模式):尽可能少的匹配内容
```
    贪婪--->非贪婪 *?  +?  ??   {m,n}?
    >>> re.findall(r'ab','abbbbbbbbbbb')
    ['ab']
    
    >>> re.findall(r'ab+','abbbbbbbbbbb')
    ['abbbbbbbbbbb']
    
    >>> re.findall(r'ab{3,5}?','abbbbbbbbbbb')
    ['abbb']
```
## 正则表达式的子组
可以使用()为正则表达式建立子组,子组可以看做是正则表达式内部操作的一个整体

子组是在正则表达式整体匹配到内容的前提下才会发挥的作用,他不影响正则表达式整体去匹配目标内容这一原则

子组作用

1.作为内部整体可以改变某些原字符的行为
    eg:
    >>> re.search(r'(ab)+\d+','abababab123456').group()
    'abababab123456'

2.子组在某些操作中可以单独提取出匹配内容
    >>> re.search(r'(https|http|ftp)://\S+','https://baidu.com').group()
    'https://baidu.com'


子组使用注意事项:
* 一个正则表达式中可以有多个子组
* 子组一般由外到内,左到右称之为第一,第二,第三...子组
* 子组不能重叠,嵌套也不宜很复杂


## 捕获组和非捕获组

格式:
```
(?P<name>pattern)

>>> re.search(r"(?P<dog>ab)cdef",'abcdefghijklmn').group('dog')
'ab'
```
作用:可以通过组名更方便获取某组内容